\chapter{Treball futur}
\label{sec:futur}


\todo{fer intro}

En aquest capítol es proposen treballs futurs a partir del que s'ha  dissertat en aquest document.

També algunes manies que hem tingut, pex la de la forta correspondència model-implementació, i la motivació que tenen pensant en el futur.


* Models

* Implementacions

* Reflexions de la qualitat



\section{Models}


En la teoria de la mesura, la incertesa sol acompanyar les mesures. La
incertesa reflecteix probabilísticament els límits del que es coneix
sobre la quantitat mesurada.  Així doncs, seria interessant poder
incorporar la incertesa en els models.  Principalment la incertesa
hauria d'acompanyar els atributs de temps i de valor de les sèries
temporals, és a dir haurien de reflectir la incertesa que hi ha en
cada mesura a l'hora d'adquirir un valor un instant de temps.
Aleshores, caldria estudiar com aquesta incertesa afecta les
operacions, és a dir com es propaga la incertesa quan s'uneixen dues
sèries temporals, quan es representen, etc.


\todo{fer}


HEm fet servir estadístics senzills (mitjana, màxim, darrer) perquè el nostre objectiu és la multiresolució i no cap funció d'agregació d'atributs en concret. En l'anàlisi de sèries temporals hi ha multitud d'algoritmes, d'allà es poden treure altres funcions d'agregació: que extreguin patrons, que cerquin periodicitats, que ajustin l'evolució en el temps de dues sèries temporals diferents, etc.

% We have showed some aggregation functions examples with simple
% aggregation statistics, mean and maximum, and simple representation
% methods, Delta and \zohe{}. More attribute aggregation functions could
% be designed based on methods from other fields such as data streaming
% or time series data mining, especially it would be interesting aggregations with uncertain data.

% * Agregacions en el domini freqüencial


No hem aprofundit en l'estudi de les f que treballen en flux, estaria bé mirar Cormode i veure com es pot aprofitar.


També l'emmagatzematge de metades, es  pot fer perfectament amb els SGBDR.



* el model sgstm s'ha fet pensant en els instants de consolidació
periòdics. Què passa quan no ho són?  per exemple event trigerred
(només emmatgatzemem informació quan creiem que és
interessant). Aleshores potser són casos molt especials i no es pot
dibuixar l'esquema? Potser posar tot això com a comentari a la secció
d'Altres Estructures: En el model de \gls{SGSTM} s'ha considerat que
la consolidació es feia periòdicament però es podria fer quan es
cregués oportú, aleshores no es pot preveure quin esquema de
multiresolució hi haurà; són casos que requereixen un estudi més
profund. Etc. 




* Aclariment sobre les operacions: algunes són perfectament conseqüència de conceptes (per exemple la diferència té un raonament a partir de la pertinença, la intersecció a partir de la diferència) altres hi ha conseqüència però s'ha de prendre una decisió (per exemple en el cas de la unió i la unió temporal s'ha de decidir quina és quina) i altres les hem definit com a passos intermedis per a altres oepracions (per exemple la concatenació temporal). En aquest darrers casos cal, doncs, cercar-ne si hi ha algun raonament o teoria sobre el qual es poden basar.





% \subsubsection{Lapses de buffer o no lapses}

% Podem tenir esquemes de multiresolució a on les diferents subsèries
% resolució coincideixin en els temps recents o a on no coincideixin:
% les subsèries més velles acabin on comencen les noves de manera
% semblant a l'estructura de buffers enllaçats.

% La primera opció pot servir per quan hi ha moltes dades tenir diferents resums preparats per a ser visualitzats, així permet triar ràpidament entre diferents zooms de les dades.

% La segona opció serveix per aprofitar al màxim la resolució i l'espai d'emmagatzematge, sense que cap subsèrie desi informació per al mateix interval de temps. Així permet conservar una sèrie temporal al llarg del seu temps amb diferents resolucions. També pot servir per usar la informació d'altres buffers i no haver de repetir emmagatzematge de buffers.







\section{Implementacions}


En les implementacions hem treballat a nivell acadèmic, és a dir sense
objectius d'optimització del rendiment. De fet, aleshores les
implementacions s'allunyarien del model i per tant del nostre objectiu
de mantenir una forta correspondència entre la forma de la
implementació i del model. Aquesta correspondència és útil per a
manteniments futurs: qualsevol millorar en el model pot ser
traslladada immediatament a les implementacions o bé, a la inversa,
qualsevol error trobat en les implementacions pot ser localitzat
fàcilment i estudiat en el model.



%RoundRobinson


Tot i així, aquesta correspondència model-implementació no sempre és
senzilla de mantenir. A Pytsms i RoundRobinson, les implementacions
més completes que hem realitzat dels models, s'hauria de simplificar
la la definició de les mesures genèriques.  En el model abstracte
matemàtic és senzill de descriure uns valors genèrics, en canvi a les
implementacions això complica l'estructura. Així, s'ha hagut de
dissenyar mesures de diferents tipus que contenen el rang del domini
de temps i valors per tal de definir les mesures indefinides, el
suprem i l'ínfim, etc.  També s'hauria de repensar la gestió de la
homogeneïtat de les sèries temporals: en el model les sèries temporals
són homogènies i en les implementacions és difícil gestionar el
concepte de nova sèrie temporal amb el mateix tipus de mesures que les
originals.

En altres casos, però, s'ha trobar una solució adequada per a
implementar la genericitat del model.  Per exemple, és el cas de la
multitud d'operacions de les sèries temporals implementades amb
Mixins, el de les representacions com a objectes independents
associats a les sèries temporals, o bé els de les funcionalitats
complementàries com l'emmagatzematge i els gràfics implementades amb
el patró Visitor. 






En les altres implementacions, l'objectiu s'ha centrat en observar
altres paradigmes d'implementació dels models. Així, ens hem pres la
llibertat de no implementar tota la genericitat del model sinó casos
simplificats. Caldria avaluar fins a quin límit aquestes
implementacions es podrien apropar més al model, per exemple a
RoundRobindoop hem notat algunes limitacions a l'hora d'usar les
funcions d'agregació d'atributs.


%RoundRobindoop

A RoundRobindoop usem Hadoop com a intèrpret de la tècnica de
programació para\l.lela MapReduce. L'execució d'aquesta tècnica
implica un compromís a l'hora d'escollir el nombre de processos en
para\l.lel ja que cada un té un cost mínim de crear-se i a més cal
comptar el cost de distribuir les dades. Es podria experimentar més
amb Hadoop en aquest sentit, és a dir amb diferents quantitats de maps
i de reduces. De fet només hem provat amb un node de computació, però
Hadoop té la possibilitat de distribuir a més nodes.


Hi ha altres projectes que també utilitzen Hadoop com a sistema
d'emmagatzematge distribuït de sèries temporals. Aquest és el cas
d'OpenTSDB \parencite{opentsdb}, que utilitza Hadoop per a
emmagatzemar i recuperar ràpidament sèries temporals.  Aquest, però,
només no té en compte l'aplicació de consultes a les dades sinó només
recuperar les dades originals.  RoundRobindoop és una solució per a
computar la multiresolució a Hadoop. Així doncs, OpenTSDB i
RounbdRobindoop podrien treballar conjuntament: el primer per a
emmagatzemar distribuïdament les sèries temporals i el segon per a
calcular la multiresolució aprofitant que les dades ja estan
distribuïdes en diversos nodes.



%Relstsms


A Reltsms hem implementat el model d'\gls{SGST} seguint la programació
acadèmica del model relacional. Es podria seguir la mateixa
aproximació per a implementar també el model d'\acro{SGSTM}.  En
aquestes implementacions, es podria experimentar amb un dels punts
forts dels \gls{SGBDR}: l'optimització de les
consultes \parencite[\gls{capitol}~18
\emph{Optimization}]{date04:introduction8}. Les expressions
relacionals són d'alt nivell matemàtic i això permet trobar
expressions equivalents a una consulta. Aleshores, els sistemes poden
decidir quina expressió és la millor per a ser executada.  En aquest
sentit, hem definit els operador de Reltsms a partir dels operadors
relacionals. Això no obstant, s'hauria d'estudiar si a Tutorial~D les
funcionalitats d'optimització s'estenen automàticament als operadors
derivats dels primitius.




\todo{fer}


en un sentit relacional, també s'ha d'estudiar Dee. sobretot per veure si RoundRobinson podria aprofitar-lo com a base.

* Implentació RoundRobinson: ha quedat de forma semblant a Dee, és a dir que és una API en Python que té orientació de \gls{SGBD}. És a dir, l'usuari quan treballa amb RoundRobinson pot tenir perfectament una estructura mental de com si treballés amb una base de dades.





%Experiment amb dades


* Experimentació amb dades: només demostrem el correcte funcionament de la multiresolució. No avaluem rendiment dels recursos, per exemple no avaluem temps de computació només n'hem mostrat un a tall de referència orientativa.  Cal provar amb més diversitat: dades de diferent mida, de diversa naturalesa, diferents esquemes de multiresolució, dades de referència utilitzades en altres recerques (per exemple keogh?)





* Implementar variacions dels \gls{SGSTM}


  Una mostra que es pot millorar molt
el codi és que canviant mètode add de les TimeSeries amb
MeasureTotalEquality hem aconseguit una millora espectacular de temps
de computació: en la inserció cal cercar que no hi hagin temps
repetits i ara s'aprofita la cerca dels sets de Python mitjançant
hash.









\subsection{Hard}


\todo{fer}


Això no obstant, el rendiment ja no és només calcular en poc temps, sinó que en alguns contextos pot ser un consum baix d'energia, ocupar poc espai, etc.
És a dir, que hi ha contextos i en cadascun el rendiment vol dir una cosa o una altra. Dir això per a introduir la implementació Hard







\subsection{RRDtool}

\todo{fer}


Ara hauríem de reprendre RRDtool i avaluar fins a quin punt compleix el nostre model. 
Segur que hi ha punts en què no compleix... 

Podem dir que RRDtool és la implementació productiva que actualment més s'apropa al concepte de multiresolució que hem formalitzat.


Regarding other implementations,
% \emph{RRDtool} can be seen as an specific case of \acro{MTSMS} and as
% a NoSQL system, although Oetiker \cite{rrdtool} has not commented
% it. However, regardless of the implementation backend, we have shown
% how a generic model for \acro{MTSMS} can be defined firmly rooted on
% \acro{DBMS} algebra theory.






% RRDtool té una estructura multiresolució amb un buffer únic d'entrada
% i buffers orientats a stream; segons havíem avaluat anteriorment \parencite{llusa11:tfm}.


% S'ha d'estudiar com es fan les consultes a RRDtool

% \url{http://en.wikipedia.org/wiki/RRD_Editor}



% Podem considerar que:

% 1. RRDtool és un SGBD NoSQL?
% 2. Nosaltres n'hem formalitzat un model lògic?
% 3. És el primer model lògic per a un producte NoSQL?
% 4. Aquest model lògic es pot implementar tant en productes relacionals com amb NoSQL? i per tant es demostra que els models lògics són extremadament potents i necessaris?
% 5. La implementació que fa RRDtool és molt eficient per a un determinat camp d'aplicació?
% 6. La implementació relacional seria molt genèrica i propera al model però no tan eficient? més aviat subjecte a l'eficiència genèrica dels SGBDR?
% 7. Els SGST són uns SGBD més simples? no tenen tantes actualitzacions de valors, no hi ha tantes relationships en l'esquema... Els SGST només es preocupen de sèries temporals i per tant només d'un tipus de dades en concret, això no obstant tal com s'ha dissenyat el model aquest tipus de dades es pot implementar en SGBD més complexos. 

Hi ha RRDtool, que és un SGBD específic dissenyat per a dades monitorades. Les causes del seu disseny són:

* Tobias Oetiker dissenyava un monitor de paràmetres de xarxes de comunicacions i en aquest monitor una part era la d'emmagatzematge de les dades. Per raons pràctiques i d'utilitat dissenya aquesta part amb un esquema inovadós. Finalment acaba separant aquesta part i la converteix independentment en RRDtool.

* RRDtool té aquest model pràctic i a la pràctica és molt útil per a ser usat com a SGBD dels sistemes de monitoratge, sobretot en l'àmbit dels comptadors de xarxa on és l'estàndard de facto. 

Això no obstant, no hi ha cap raonament teòric sobre el model de RRDtool ja que s'ha dissenyat per raons pràctiques. Per tant, entendre el funcionament de RRDtool és complicat, hi ha un nivell molt elevat per començar a fer-lo funcionar i molts conceptes no s'entenen perquè no estan ben definits. 

Per això ens proposem de compendre i formalitzar el model de RRDtool, que acabarem anomenar model de multiresolució, en la teoria dels sitemes d'informació. A més RRDtool és molt específic pel camp de comptadors de xarxa i volem oferir un model genèric per a altres àmbits.  









\section{Reflexions de la qualitat}


\todo{fer}


En el cas que es conegui més bé el context i el comportament de la
sèrie temporal a què s'aplica la multiresolució, es pot detallar més
bé la quantificació de l'error: és a dir en termes de la teoria de
la informació aleshores tenim més coneixement sobre la predicció del
comportament de les dades i podem utilitzar-ho per a avaluar
característiques més concretes.

Cal notar que no avaluem la idoneïtat d'aplicar un estadístic o un
altre a unes dades ni quin és el que més bé va per a obtenir una
informació, només plantegem el cas que algú vol aplicar una consulta
amb una agregació determinada a una sèrie temporal i quin error
tindria si en comptes de a les dades originals ho aplica a les dades
multiresolucionades.


* Tampoc hem avaluat com xoca la informació de diversos discs d'una mateixa sèrie temporal multiresolució. Què passa quan hi ha més d'una resolució? quan és del mateix agregador, quan és de diferent?   En cas que es perdi un disc es podria reconstruir a partir dels altres? o bé en cas que es vulgui ampliar la mida d'un disc, es podria farcir amb dades dels altres? Per exemple avaluar les resolucions encadenades: afegeixen més restriccions a la compressió d'informació.

* En cas que s'hagi de canviar alguna cosa ja emmagatzemada a la
  multiresolució, a banda dels sistemes duals descrits, també es
  podria utilitzar informació emmagatzemada en altres discs. Ara bé
  això requereix una anàlisi més complicada de la informació de
  multiresolució, semblant a analitzar la informació en resolucions
  encadenades.




















% \subsubsection{Operacions habituals en les sèries temporals}


% \paragraph{Semblança de dues sèries temporals}


% Similarity Measures for Time Series

% Hi ha varis mètodes, [keogh08:vldb] n'avalua uns quants i els generalitza amb:

% Given two
% time series T1 and T2 , a similarity function Dist calcu-
% lates the distance between the two time series, denoted by
% Dist(T1 , T2 ).

% Exemplifiquem amb la distància euclídia, [keogh08:vldb] nota que és
% competitiva amb les altres.

% Distancia euclídia segons [faloutsous94-sigmod]


% \[
% D(S,Q) = \left( \sum_{i=1}^{l} (S[i]-Q[i])^2  \right)^{1/2}
% \]

% \begin{gather*}
%   D: S \times Q \longrightarrow v: \\
%   S' = map(fusio(S,Q),(t,v_1,v_2)\mapsto(t,(v_1-v_2)^2)), \\
%   S'' = fold(quad,(0,0),(t^1,v^1,t^2,v^2)\mapsto(t^1,v^1+v^2)), \\
%   v = \sqrt{V(m)}:m\in S''
% \end{gather*}


% S i Q haurien de ser regulars entre elles, sinó cal aplicar una fusió amb representació/interpretació.

% Amb la multiresolució la fusió es pot fer de forma eficient. Per altra banda, es podria crear un disc resolució amb agregador de semblança.


% \paragraph{Semblança de dues sèries temporals amb offset}

% Aquí es descriu la solució general del problema (SequentialScan),
% [faloutsous94-sigmod] n'estudia implementacions amb certes
% heurístiques que aconsegueixen més eficiència.





% \paragraph{Filtratge senzill per mitjana mòbil}

% Sigui $p$ la mida de la finestra mòbil
% \begin{gather*}
%   \text{MitMobil}: S \times \text{p} \longrightarrow S':\\
%   \text{map}(S,(t,v)\mapsto \text{mitjanaV}(S[t,t+p]))
% \end{gather*}


% Mitjana mòbil sobre la multiresolució



% \paragraph{Farciment de forats}

% Jo tinc una sèrie temporal i vull que entre dues mesures no hi hagi més d'un cert temps. Si no es compleix dic que té forats. 

% Sigui $S$ una sèrie temporal, aquesta té forats de més durada que $d$
% si alguna mesura compleix $\text{forats}(S,d) = \text{selecciona}(difT(S),v>d \bigwedge v\neq\infty)$ a on $difT(S) = \text{map}(\text{tpredecessors}(S),(t,v)\mapsto(t,t-v))$.

% Amb la multiresolució el farciment de forats és natural a l'estructura i és controlat per la funció agregadora d'atributs.


% * Com farciria els forats manualment a una sèrie temporal?

% 1. Passar-ho per un esquema de multiresolució

% 2. Treballar sobre la sèrie temporal:

% a partir del càlcul de forats anterior $\text{forats}(S,d)$ per
% exemple apliquem un farciment amb representació
% zohe. $\text{farciment}(S,d) = \text{unio}(S,S')$ a on fem la selecció
% de resolució $S' = S[T]^{\text{zohe}}$, $\forall (t,v) \in
% \text{forats}(S,d): T = \{ \tau = t - dn |
% \tau\in(t-v,t),n\in\mathbb{N} \}$.







% \subsubsection{Com treure profit de les operacions dels SGSTM}

% Temes que després es poden aprofitar a les implementacions

% * No hi ha updates --> les sèries temporals no s'han de canviar

% * Per exemple, vull calcular la mitjana de  BDSTM(a,b] si tinc un disc resolució amb $\delta=b-a$ i $f=$mitjana aquest seria l'adequat en comptes de calcular mitjana(SerieTotal(M)(a,b])

% %??
% % No obstant, la base de dades multiresolució conté informació sobre la
% % resolució de les subsèries i per tant aquesta operació és susceptible
% % d'implementar-se aprofitant aquesta informació.  A tall d'exemple es
% % defineix una operació per extreure de la base de dades multiresolució
% % una sèrie temporal regular amb període $T$:


% % \begin{definition}[Selecció de resolució regular]
% %   \begin{gather*}
% %     \text{ResolucióRegular}: M^* \times T \times r \longrightarrow S'\\
% %     \forall (S_{Bi},S_{Di},\delta_i,\tau_i,k_i,f_i) \in M : \\
% %     d_i = T - \delta_i , \\
% %     0 \geq d_0 > d_1 \dots > d_a, 0 < d_{a+1} < \dots < d_d: \\
% %     S'' = S_{D0} || S_{D1} || \dotsb || S_{Da}  ||  S_{Da+1} || \dotsb || S_{Dd}, \\
% %     S' = S''[i]^r: i = {t|0+nT,n\in\mathbb{N}}
% %   \end{gather*}
% % \end{definition}

% % Nota: les operacions no són equivalents, l'operació $\text{SerieTotal}(M)[i]^r$ és molt més potent que la $\text{ResolucióRegular}(M,T)$.




% \subsubsection{Semàntica de comportament}

% \todo{?}









%%% Local Variables:
%%% TeX-master: "main"
%%% End:
% LocalWords:  SGSTM
