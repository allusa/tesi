
% \section{Implementation}

% \todo{}

% We implement the TSMS and MTSMS models into three different approaches:

% \begin{itemize}
% \item Pytsms+RoundRobinson, a Python implementation. This is our referent
%   implementation, which we use for example data.
% \item Reltsms, a Tutorial D implementation. This shows a TSMS
%   implemented on a relational language.
% \item Roundrobindoop, a MapReduce implementation. This is a specific
%   implementation for offline computing multiresolution with
%   parallelism approaches.
% \end{itemize}

% RRDtool can also be seen as a MTSMS implementation in a specific
% field. We give more references for RRDtool in
% Section~\ref{sec:related-work}.



\section{Referent implementation}
\label{sec:implementation}

We implement the TSMS and MTSMS models with Python. This is our
referent implementation, which we use for example data.  

We implement the two models of TSMS and MTSMS respectively as two
separated Python libraries: \emph{Pytsms} and \emph{RoundRobinson}.
RoundRobinson has a strong dependency on Pytsms following the MTSMS
being defined based on TSMS.  It is mainly a referent implementation
so it has fidelity to the algebraic model defined but has not extended
\acro{DBMS} capabilities, such would be query optimisation or
transaction management.

We design the implementation concepts with object orientation, so that
there is a clear mapping between model and implementation
objects. Next we use Unified Modeling Language (UML) diagrams in order
to define the classes structure, mainly to show the relationships
among objects.


% The development of this implementation is located at our version control system
% \url{http://escriny.epsem.upc.edu/svn/rrb//src/pytsms/tags/0.1}.


\subsection{Pytsms}

Pytsms is the referent implementation for the model concepts of
measure, time series and temporal representation function.  Figure
\ref{fig:implementacio:pytsms-uml} shows the relationships among these
objects in a UML diagram. A \emph{TimeSeries} object is an aggregation
of \emph{Measure} objects. TimeSeries and \emph{Representation}
objects are associated, that is each TimeSeries has a default
representation and a Representation operates over a TimeSeries.

\begin{figure}[tp]
  \centering
  \begin{tikzpicture}

  %Timeseries
  \umlclass[x=0,y=0] {TimeSeries}{}{}  

  % Measure
  \umlclass[x=-1.5,y=-2] {Measure}{}{}
  \umluniaggreg[mult=0..*]  {TimeSeries}{Measure}
  %\umlclass[x=-5.2,y=-2] {MFloat}{}{}
  %\umlclass[x=-2.8,y=-2] {MChar}{}{}
  %\umlinherit {MFloat}{Measure}
  %\umlinherit {MChar}{Measure}

  %Repr
  \umlclass[x=3.5] {Representation}{}{} %,type=abstract
  \umlassoc[mult1=1,mult2=1]  {TimeSeries}{Representation}
  \umlclass[x=2.5,y=-2] {Zohe}{}{}
  \umlclass[x=4.5,y=-2] {Delta}{}{}
  \umlinherit {Zohe}{Representation}
  \umlinherit {Delta}{Representation}

  %Associacions
  \umlclass[x=-1.25,y=-4] {RegularProp}{}{}
  \umluniassoc  {TimeSeries}{RegularProp}
  \umlclass[x=1.25,y=-4] {Storage}{}{}
  \umluniassoc {TimeSeries}{Storage}

  %Dependencies
  \umlemptypackage[x=4,y=-4]{Matplotlib}
  \umldep{Zohe}{Matplotlib}
  \umldep{Delta}{Matplotlib}


  \end{tikzpicture}



  \caption{Pytsms UML class diagram}
  \label{fig:implementacio:pytsms-uml}
\end{figure}




A TimeSeries object has a huge amount of methods, we classify them
based on their functionality. Firstly, a TimeSeries has methods that
manipulate its structural model, a TimeSeries is a subclass of the
predefined Set Python type. Secondly, there are methods for the
operational model which are classified into set, sequence and temporal
function operators.  Set operators are composed of the partial order,
the temporal order and the relational set operators.  Thirdly,
complementary operations for TimeSeries are grouped into two visitor
objects: \emph{RegularProp} groups the regularity operation
definitions and \emph{Storage} has methods for storing and retrieving
time series from file system. Visitor is a pattern design that allows
new functionality to be added to objects without modifying the
objects \cite{ziade08:expert_python_programming:visitor,martin02:visitor}.


Figure \ref{fig:implementacio:pytsms-uml} shows two specialisations
for Representation. We show the two exemplified representations
\emph{Zohe} and \emph{Delta}. Basically, each particular
Representation has the graph and the temporal interval operation
definition. Furthermore, there is also a method for plotting
coherently the time series to its representation; for which we use the
Python \emph{Matplotlib} library.



\begin{example}
  We define in Pytsms the two time series $S1$ and $S2$ from
  Example~\ref{ex:model:s1s2} and we apply different operations:
  union, concatenation, closed interval, \zohe{} temporal interval,
  \zohe{} temporal selection, and the test of regular property.
\begin{lstlisting}[style=py]
#Importing the required objects
>>> from pytsms import TimeSeries, Measure
>>> from pytsms.representation import Zohe
>>> from pytsms.properties import isRegular

#Defining the two time series
>>> s1 = TimeSeries([Measure(1,1),Measure(3,1),Measure(4,0),Measure(5,1)])
>>> s2 = TimeSeries([Measure(2,2),Measure(3,2),Measure(4,0),Measure(6,2)])

#Manipulating the two time series
# æ$s1 \cup s2$æ
>>> s1.union(s2)
TimeSeries([m(1,1), m(2,2), m(3,1), m(4,0), m(5,1), m(6,2)])
# æ$s1 || s2$æ
s1.concatenate(s2) 
TimeSeries([m(1,1), m(3,1), m(4,0), m(5,1), m(6,2)])
# æ$s2[2,5]$æ
>>> s2.interval_closed(2,5)
TimeSeries([m(2,2), m(3,2), m(4,0)])
# æ$s2[2,5]^\zohe$æ
>>> s2.interval_temporal(2,5,Zohe)
TimeSeries([m(3,2), m(4,0), m(5,2)])

#Checking the regularity
# æ$s2$æ is not regular
>>> s2.accept(isRegular())
False
# æ$s2$æ can be regularised by æ$s2[{0,2,4}]^\zohe$æ
>>> r2 = s2.selection_temporal(range(0,6,2),Zohe)
>>> r2
TimeSeries([m(0,2), m(2,2), m(4,0)])
>>> r2.accept(isRegular())
True
\end{lstlisting}
\end{example}





\subsection{RoundRobinson}


RoundRobinson is the referent implementation for the model concepts of
multiresolution time series, resolution subseries, buffers, discs, and
attribute aggregate functions. Figure
\ref{fig:implementacio:roundrobinson-uml} shows the relationships
among these objects in a UML diagram. A \emph{MultiresolutionSeries}
object is an aggregation of \emph{Resolution} objects. A
\emph{Resolution} is composed of one \emph{Buffer} and one
\emph{Disc}. Each Buffer is associated to one TimeSeries, from the
Pytsms library, and each Disc is associated to another TimeSeries,
which respectively are $S_B$ and $S_D$ of the MTSMS
model. Furthermore, each Buffer is associated to one attribute
aggregate function which is realised by defining a Python
\emph{Function} with two parameters: a TimeSeries (\emph{s}) and a
consolidation interval (\emph{i}) as a pair of two time instants.




\begin{figure}[tp]
  \centering

\begin{tikzpicture}

  %MultiTimeseries
  \umlclass[x=0,y=0] {MultiresolutionSeries}{}{}  
  %\umlclass[x=-4,y=0] {Set}{}{}
  %\umlinherit{MultiresolutionSeries}{Set}
  %Components 
  \umlclass[x=0,y=-2] {Resolution}{}{}
  \umluniaggreg  {MultiresolutionSeries}{Resolution}
  %SubComponents 
  \umlclass[x=-1.2,y=-4] {Buffer}{}{}
  \umlclass[x=1.2,y=-4] {Disc}{}{}
  \umlclass[x=-3,y=-6,template={s,i}] {Function}{}{}
  \umlunicompo[mult=1]  {Resolution}{Buffer}
  \umlunicompo[mult=1]  {Resolution}{Disc}
  \umluniassoc[mult=1]  {Buffer}{Function}

  %TimeSeries
  \begin{umlpackage}[x=1,y=-6]{Pytsms}
    \umlclass{TimeSeries}{}{}  
  \end{umlpackage}
  \umluniassoc[mult=1]  {Buffer}{TimeSeries}
  \umluniassoc[mult=1]  {Disc}{TimeSeries}

  %Associacions
  \umlclass[x=-3,y=-2.5] {Storage}{}{}
  \umluniassoc {Storage}{MultiresolutionSeries}
  \umlclass[x=-3,y=-1] {Plot}{}{}
  \umluniassoc {Plot}{MultiresolutionSeries}

\end{tikzpicture}

  \caption{RoundRobinson UML class diagram}
  \label{fig:implementacio:roundrobinson-uml}
\end{figure}



A MultiresolutionSeries is a subclass of the predefined Set Python
type. It has complementary operations that are grouped into two
objects: \emph{Storage} has methods for storing and retrieving
multiresolution time series from file system and \emph{Plot} has
methods for plotting the time subseries of the multiresolution schema.


A MultiresolutionSeries has a method \emph{addResolution} for defining
the multiresolution schema structure by adding resolution
subseries. Every new resolution is configured by four parameters:
\emph{delta}, \emph{k}, \emph{f}, and \emph{tau} that create the
corresponding buffer and disc.  A MultiresolutionSeries has methods
\emph{add}, \emph{consolidable}, and \emph{consolidate} that operate on
the corresponding methods of the contained resolution subseries.


A MultiresolutionSeries can be queried by two methods:
\emph{discSeries} and \emph{total}. \emph{discSeries} returns the
TimeSeries for the selected disc by parameters \emph{delta} and
\emph{f}. \emph{total} returns the TimeSeries that results from the
concatenation of all \emph{discSeries} ordered by \emph{delta}; as
there can not be repeated \emph{delta}, \emph{total} has a parameter
\emph{f} for selecting only \emph{discSeries} with a determined
attribute aggregate function.

In a module \emph{aggregators} we have implemented some default
attribute aggregate functions, although users can define more as they
are Python Function objects with parameters s as a TimeSeries and i as
a pair of times like [t0,tf]. For example we have defined the \zohe
aggregate functions, which basically aggregate over the temporal
interval \lstinline[style=py]+s.interval_temporal(t0,tf,Zohe)+.


\begin{example}
  We define in Pytsms the time series $S$ and in RoundRobinson we
  define the multiresolution time series $M_\emptyset$ from
  Example~\ref{ex:model:smultiresolution}, we apply consolidation and
  we query the result.

\begin{lstlisting}[style=py]
#Importing the required objects
>>> from pytsms import TimeSeries, Measure
>>> from roundrobinson import MultiresolutionSeries
>>> from roundrobinson.aggregators import mean_zohe,maximum_zohe

#Defining the original time series
>>> s = TimeSeries([Measure(1,6),Measure(5,2),Measure(8,5),Measure(10,0),Measure(14,1),Measure(19,6),Measure(22,11),Measure(26,6),Measure(29,0)])

#Defining the multiresolution time series
>>> M = MultiresolutionSeries()
#Defining the multiresolution schema
>>> M.addResolution(delta=5,k=4,f=mean_zohe,tau=0)
>>> M.addResolution(delta=10,k=2,f=maximum_zohe,tau=0)

#Adding the measures
>>> for m in s: M.add(m)
#M is consolidable
>>> M.consolidable()
True
#Consolidating until no more consolidable
>>> while M.consolidable(): M.consolidate()

#Query æ$\seriedisc(M,5,\text{mean}^\zohe)$æ
>>> M.discSeries(5,mean_zohe)
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
#Query æ$\seriedisc(M,10,\text{maximum}^\zohe)$æ
>>> M.discSeries(10,maximum_zohe)
TimeSeries([m(10,6), m(20,11)])
#Query æ$\totalseries(M)$æ
>>> M.total()
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
\end{lstlisting}
\end{example}



%%% Local Variables:
%%% TeX-master: "main"
%%% ispell-local-dictionary: "british"
%%% End:
