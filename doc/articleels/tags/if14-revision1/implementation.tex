\section{Reference implementation}
\label{sec:implementation}

In this section we briefly describe a reference implementation of the
models introduced in Sections~\ref{sec:model:TSMS}
and~\ref{sec:MTSMS}. This implementation is given as a proof of
concept and do not seeks to be an efficient nor a complete database
system. We implemented the \acro{TSMS} and \acro{MTSMS} models using
then Python~\cite{python:doc2} programming language.

The implementations of the two models, \acro{TSMS} and \acro{MTSMS},
are organized respectively in two separated Python libraries:
\texttt{Pytsms} and \texttt{RoundRobinson}.  \texttt{RoundRobinson}
has a strong dependency on \texttt{Pytsms} following the dependency of
\acro{MTSMS} on \acro{TSMS}.  The code of this implementation can be
found at~\cite{llusa:roundrobinson}.

The reference implementation follows the object orientated paradigm
and it observes a clear mapping between the model and the object
classes. Unified Modeling Language~(\acro{UML}) diagrams are used to
define the classes structure.  Operations are implemented as object
methods, which are not show in \acro{UML} diagrams for space reasons.


\subsection{Pytsms}

\texttt{Pytsms} is the reference implementation for the model concepts
of measure, time series and temporal representation function.
Figure~\ref{fig:implementacio:pytsms-uml} shows the relationships
among these objects in a \acro{UML} diagram. A \texttt{TimeSeries}
object is an aggregation of \texttt{Measure}
objects. \texttt{TimeSeries} and \texttt{Representation} objects have
a relation of association, that is each \texttt{TimeSeries} has a
default representation and a \texttt{Representation} operates over a
\texttt{TimeSeries}.

%\tikzsetnextfilename{fig_pytsms_uml}
\begin{figure}[tp]
  \centering
  %\input{imatges/pytsms-uml.tex}
  \includegraphics{fig_pytsms_uml.pdf}
  \caption{Pytsms \acro{UML} class diagram}
  \label{fig:implementacio:pytsms-uml}
\end{figure}


A \texttt{TimeSeries} object has a big amount of methods. We classify
them based on their functionality. First, a \texttt{TimeSeries} object
includes methods to manipulate the structural model. We implement
\texttt{TimeSeries} as a subclass of the predefined \texttt{set}
Python type. Second, a \texttt{TimeSeries} object has methods that
implement set, sequence and temporal function operators as described
in Section~\ref{sec:model:operations}.  Third, accessory operations of
\texttt{TimeSeries} are grouped into two visitor objects:
\texttt{RegularProp} groups the regularity operation definitions and
\texttt{Storage} has methods for storing and retrieving time series
from the file system. Recall that visitor is a pattern design that
allows new functionality to be added to objects without modifying the
objects~\cite{ziade08:expert_python_programming:visitor,martin02:visitor}.

Figure~\ref{fig:implementacio:pytsms-uml} shows two specialisations
for \texttt{Representation} that refer to the representation functions
given in Section~\ref{sec:model:tfunc}. Basically, each actual
\texttt{Representation} defines the graph and the temporal interval
operation. Furthermore, there is also a method to plot coherently the
time series to its representation; for which we use the Python
\emph{Matplotlib} library.
%
% Aqui hi els temes que he comentat en la revisio de la primera part
% SBS



\begin{example}
  \label{ex:pytsms:example}
  In this example we reproduce an interpreter session working with
  \texttt{Pytsms}. First we define the two time series \texttt{s1} and
  \texttt{s2} from Example~\ref{ex:model:s1s2} and after that we apply
  different operations: union, temporal union, concatenation, closed
  interval, \zohe{} temporal interval, \zohe{} temporal selection, and
  the test of regular property. Note that \texttt{Measure} is
  abbreviated to \texttt{m}. The log of the session is as follows:

  {\small
\begin{verbatim}
# Import the required objects
>>> from pytsms import TimeSeries, Measure as m
>>> from pytsms.representation import Zohe
>>> from pytsms.properties import isRegular

# Define the two time series
>>> s1 = TimeSeries([m(1,1),m(3,1),m(4,0),m(5,1)])
>>> s2 = TimeSeries([m(2,2),m(3,2),m(4,0),m(6,2)])

# Manipulate the two time series
>>> s1.union(s2)
TimeSeries([m(1,1), m(2,2), m(3,1), 
            m(4,0), m(5,1), m(6,2)])
>>> s1.union_temporal(s2)
TimeSeries([m(1,1), m(2,2), m(4,0), m(5,1), m(6,2)])
>>> s1.concatenate(s2) 
TimeSeries([m(1,1), m(3,1), m(4,0), m(5,1), m(6,2)])
>>> s2.interval_closed(2,5)
TimeSeries([m(2,2), m(3,2), m(4,0)])
>>> s2.interval_temporal(2,5,Zohe)
TimeSeries([m(3,2), m(4,0), m(5,2)])

# Check for regularity
>>> s2.accept(isRegular())
False
# regularise to {0,2,4} by Zohe method
>>> r2 = s2.selection_temporal(range(0,6,2),Zohe)
>>> r2
TimeSeries([m(0,2), m(2,2), m(4,0)])
>>> r2.accept(isRegular())
True
\end{verbatim}
}
\end{example}





\subsection{RoundRobinson}

RoundRobinson is the referent implementation for the model concepts of
multiresolution time series, resolution subseries, buffers, discs, and
attribute aggregate functions. Figure
\ref{fig:implementacio:roundrobinson-uml} shows the relationships
among these objects in a \acro{UML} diagram. A
\emph{MultiresolutionSeries} object is an aggregation of
\emph{Resolution} objects. A \emph{Resolution} is composed of one
\emph{Buffer} and one \emph{Disc}. Each \emph{Buffer} is associated to
one \emph{TimeSeries}, from the Pytsms library, and each \emph{Disc}
is associated to another \emph{TimeSeries}, which respectively are
$S_B$ and $S_D$ of the \acro{MTSMS} model. Furthermore, each
\emph{Buffer} is associated to one attribute aggregate function which
is realised by defining a Python \emph{Function} with two parameters:
a \emph{TimeSeries} (\emph{s}) and a consolidation time interval
(\emph{i}).

%\tikzsetnextfilename{fig_roundrobinson_uml}
\begin{figure}[tp]
  \centering
  %\input{imatges/roundrobinson-uml.tex}
  \includegraphics{fig_roundrobinson_uml.pdf}
  \caption{RoundRobinson \acro{UML} class diagram}
  \label{fig:implementacio:roundrobinson-uml}
\end{figure}


A \emph{MultiresolutionSeries} is a subclass of the predefined \emph{Set} Python
type. It has complementary operations that are grouped into two
objects: \emph{Storage} has methods for storing and retrieving
multiresolution time series from file system and \emph{Plot} has
methods for plotting the time subseries of the multiresolution schema.


A \emph{MultiresolutionSeries} has a method \emph{addResolution} for defining
the multiresolution schema structure by adding resolution
subseries. Every new resolution is configured by four parameters:
\emph{delta}, \emph{k}, \emph{f}, and \emph{tau} that create the
corresponding buffer and disc.  A \emph{MultiresolutionSeries} has methods
\emph{add}, \emph{consolidable}, and \emph{consolidate} that operate on
the corresponding methods of the contained resolution subseries.


A \emph{MultiresolutionSeries} can be queried by two methods:
\emph{seriedisc} and \emph{totalseries}. The \emph{seriedisc} returns
the \emph{TimeSeries} for the selected disc by parameters \emph{delta}
and \emph{f}. The \emph{totalseries} returns the \emph{TimeSeries}
that results from the concatenation of all \emph{seriedisc} ordered by
\emph{delta}.
% as there can not be repeated \emph{delta}, \emph{totalseries} has a
% parameter \emph{f} for selecting only \emph{discSeries} with a
% determined attribute aggregate function.

In a module \emph{aggregators} we have implemented some default
attribute aggregate functions, although users can define more as they
are Python \emph{Function} objects with parameters \emph{s} as a
\emph{TimeSeries} and \emph{i} as a pair of times like
\emph{[ti,tj]}. As instance we have defined the \zohe{} aggregate
functions from Section~\ref{sec:model:interpolador}, which basically
aggregate over the temporal interval
\verb|s.interval_temporal(ti,tj,Zohe)| shown in
Example~\ref{ex:pytsms:example}.


\begin{example}
  We define in Pytsms the time series $S$ and in RoundRobinson we
  define the multiresolution time series $M_\emptyset$ from
  Example~\ref{ex:model:smultiresolution}, we apply consolidation and
  we query the result.

{\small
\begin{verbatim}
#Importing the required objects
>>> from pytsms import TimeSeries, Measure as m
>>> from roundrobinson import MultiresolutionSeries
>>> from roundrobinson.aggregators import mean_zohe,maximum_zohe

#Defining the original time series
>>> s = TimeSeries([m(1,6),m(5,2),m(8,5),m(10,0),m(14,1),m(19,6),m(22,11),m(26,6),m(29,0)])

#Defining the multiresolution time series
>>> M = MultiresolutionSeries()
#Defining the multiresolution schema
>>> M.addResolution(delta=5,k=4,f=mean_zohe,tau=0)
>>> M.addResolution(delta=10,k=2,f=maximum_zohe,tau=0)

#Adding the measures
>>> for m in s: M.add(m)
#M is consolidable
>>> M.consolidable()
True
#Consolidating until no more consolidable
>>> while M.consolidable():
...    M.consolidate()

#Query the consolidated discs 
>>> M.seriedisc(5,mean_zohe)
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
>>> M.seriedisc(10,maximum_zohe)
TimeSeries([m(10,6), m(20,11)])
#Query the total time series
>>> M.totalseries()
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
\end{verbatim}
}
\end{example}





%%% Local Variables:
%%% TeX-master: "main"
%%% ispell-local-dictionary: "british"
%%% End:
