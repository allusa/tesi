\chapter{Implementació relacional amb Tutorial~D}

Els models \gls{SGST} i \gls{SGSTM} es basen fortament en l'àlgebra
relacional.  Així doncs, n'explorem una implementació en un
\gls{SGBDR}. Per tal de mantenir la màxima fidelitat amb els models i
per les consideracions de \textcite[cap.~1--4]{date04:introduction8}
sobre la idoneïtat del llenguatge \gls{SQL} en el model relacional,
implementem els models amb el llenguatge acadèmic dels \gls{SGBDR}:
\emph{Tutorial~D} \parencite{date04:introduction8,date:thethirdmanifesto,date:tutoriald}. Com
a intèrpret per a aquest llenguatge utilitzem Rel \parencite{rel}, el
qual és un \gls{SGBDR} de propòsit acadèmic per a experimentar amb
Tutorial~D.


% Tutorial D is a specific D which is defined and used for illustration in The Third Manifesto. Implementations of D need not have the same syntax as Tutorial D. The purpose of Tutorial D is both educational and to show what a D might be like. Rel is an implementation of Tutorial D.
% Rel is an open source true relational database management system that implements a significant portion of Chris Date and Hugh Darwen's Tutorial D query language.
% Primarily intended for teaching purposes, Rel is written in the Java programming language.



Implementem la part essencial, és a dir l'àlgebra definida en els
models lògics. Com que són de propòsit acadèmic, ni Tutorial~D ni Rel
implementen els complements que tenen els \gls{SGBDR} en entorns
d'explotació. Com a conseqüència, les implementacions resultants són
útils per a comprovar l'àlgebra relacional però no són còmodes per a
treballar amb dades reals, les quals necessiten sovint operacions
per canviar-ne el format, per dibuixar-les, etc.




\section{SGST relacional}


Tal com s'ha definit el model estructural de \gls{SGST}, en el model
relacional les sèries temporals són relacions amb dos atributs: $t$
pel temps i $v$ pels valors, on l'atribut $t$ fa de clau primària en
les variables relació.  Les mesures són els tuples d'aquestes
relacions.  Per tant, la implementació relacional consisteix a definir
un tipus sèrie temporal i totes les operacions associades. Aquestes
definicions es basaran en Tutorial~D, és a dir que no cal cap
llenguatge no relacional extern.

Tutorial~D defineix estàticament els tipus dels paràmetres de les
operacions, la qual cosa dificulta generalitzar-les per a qualsevol
tipus de temps i valor com s'ha fet a la implementació amb Python. Com
a conseqüència, fixarem a reals els tipus dels atributs temps i dels
valors, \emph{Rational} a Tutorial~D.


Així doncs, definim el valor de sèrie temporal mitjançant
una relació d'atributs $t$ i $v$. Per exemple la sèrie temporal $s=\{
(2,3), (3,4) \}$:
\begin{lstlisting}[style=tutorialD]
relation {
   tuple { t 2.0, v 3.0 },
   tuple { t 3.0, v 4.0 }
 }
\end{lstlisting}


A partir d'aquest valors relació s'hauria de definir el tipus sèrie
temporal. No obstant això, la definició de tipus es troba en un estat
massa experimental a Tutorial~D, com es detalla a
l'apartat~\ref{sec:implementacio:tipus-relacional}. Així doncs,
definim una variable relació \emph{timeseries} per a utilitzar-la com a
equivalent del tipus en les definicions dels operadors:
\begin{lstlisting}[style=tutorialD]
var timeseries base relation
    { t rational, v rational }  key { t } ;
\end{lstlisting}


En les sèries temporals com a relació, els tuples són les mesures del
model de \gls{SGST}. Hi ha alguns operadors dels \gls{SGST} que tenen
mesures com a paràmetres, 
% però els tuples sense formar part d'una
% relació no són un tipus vàlid a Tutorial D. 
així doncs caldria definir també un tipus per a les mesures. Per a
simplificar, definim aquestes mesures com a sèries temporals d'un sol
element, per exemple la mesura $m=(2,3)$:
\begin{lstlisting}[style=tutorialD]
relation {
   tuple { t 2.0, v 3.0 }
 }
\end{lstlisting}


A partir d'aquestes mesures com a valors relació definim els operadors
que tenen mesures com a paràmetres. Així, els dos operadors bàsics
dels \gls{SGST} per a obtenir els atributs de temps i de valor d'una mesura
són:
\begin{lstlisting}[style=tutorialD]
operator ts.t(m same_type_as (timeseries)) returns rational;
  return t from tuple from m;
end operator;

operator ts.v(m same_type_as  (timeseries)) returns rational;
  return v from tuple from m;
end operator;
\end{lstlisting}


Per exemple, per a obtenir l'atribut temps $T(m)$ de la mesura:
\begin{lstlisting}[style=tutorialD]
with relation {
   tuple { t 2.0, v 3.0 }
  } as m1: 
ts.t(m1)
\end{lstlisting}
\begin{lstlisting}[style=stdout]
2.0
\end{lstlisting}
i per a obtenir el valor $V(m)$:
\begin{lstlisting}[style=tutorialD]
with relation {
   tuple { t 2.0, v 3.0 }
  } as m1: 
ts.v(m1)
\end{lstlisting}
\begin{lstlisting}[style=stdout]
3.0
\end{lstlisting}



\subsection{Operadors}

Un cop implementat el model estructural és el torn d'implementar el
model d'operacions.  Algunes operacions dels \gls{SGST} es poden
implementar directament amb les operacions relacionals de Tutorial~D
aplicades a les relacions \emph{timeseries}, és el cas de:

\begin{itemize}
\item La projecció
\begin{lstlisting}[style=tutorialD]
with
 RELATION {
   TUPLE { t 2.0, v 3.0 },
   TUPLE { t 3.0, v 4.0 }
 } AS s:
s {t}
\end{lstlisting}
\begin{lstlisting}[style=stdout]
 t
---
2.0
3.0
\end{lstlisting}

\item La selecció
\begin{lstlisting}[style=tutorialD]
with
 RELATION {
   TUPLE { t 2.0, v 3.0 },
   TUPLE { t 3.0, v 4.0 }
 } AS s:
s where v>3.0
\end{lstlisting}
\begin{lstlisting}[style=stdout]
 t   v 
--- ---
3.0 4.0
\end{lstlisting}


\item El reanomena
\begin{lstlisting}[style=tutorialD]
with
 RELATION {
   TUPLE { t 2.0, v 3.0 },
   TUPLE { t 3.0, v 4.0 }
 } AS s:
s rename ( v as temperatura )
\end{lstlisting}
\begin{lstlisting}[style=stdout]
 t  temperatura 
--- -----------
3.0         4.0
\end{lstlisting}

\item El mapa 
  % \glsdesc{not:sgst:map} és equivalent a un \emph{extend} més una
  % projecció més un reanomena.
 % EXTEND s ADD ( <texpr> AS tp, <vexpr> as vp ) {tp,vp} RENAME (tp AS t, vp AS v)
\begin{lstlisting}[style=tutorialD]
with
 RELATION {
   TUPLE { t 2.0, v 3.0 },
   TUPLE { t 3.0, v 4.0 }
 } AS s:
extend s add ( t+v as vp) 
\end{lstlisting}
\begin{lstlisting}[style=stdout]
 t   v  vp
--- --- ---
2.0 5.0 5.0
3.0 7.0 7.0
\end{lstlisting}

\todo{}

//aggregate equivalent a summarize o a ts.fold(s,mi,texpr,vexpr)



\end{itemize}





La resta d'operacions s'han de definir. A continuació en definim
algunes d'exemple implementades a partir d'altres operadors de
l'àlgebra relacional de Tutorial~D. Tots els operadors que definim els
anomenem prefixats amb `ts.'.



L'operació d'unió és equivalent a unir la primera sèrie temporal amb
les mesures de la segona que no tenen un atribut de temps igual a
algun temps de la primera. Així, l'operador d'unió \emph{ts.union}
 és:
\begin{lstlisting}[style=tutorialD]
OPERATOR ts.union(
      s1 SAME_TYPE_AS  (timeseries), 
      s2 SAME_TYPE_AS  (timeseries)) 
      RETURNS RELATION SAME_HEADING_AS  (timeseries);
  return s1 union (s2 join (s2 {t} minus s1 {t}));
END OPERATOR;
\end{lstlisting}

Per exemple, siguin dues sèries temporals $s_1=\{(2,3),(4,2),(6,4)\}$ i $s_2=\{(1,2),(5,3),(6,5),(10,1)\}$ la unió $s_1\cup s_2$ és :
\begin{lstlisting}[style=tutorialD]
with 
 RELATION {
   TUPLE { t 2.0, v 3.0 },
   TUPLE { t 4.0, v 2.0 },
   TUPLE { t 6.0, v 4.0 }
  } AS s1,
 RELATION {
   TUPLE { t 1.0, v 2.0 },
   TUPLE { t 5.0, v 3.0 },
   TUPLE { t 6.0, v 5.0 },
   TUPLE { t 9.0, v 1.0 }
  } AS s2: 
ts.union(s1,s2)
\end{lstlisting}
\begin{lstlisting}[style=stdout]
 t   v 
--- ---
1.0 2.0
2.0 3.0
4.0 2.0
5.0 3.0
6.0 4.0
9.0 1.0
\end{lstlisting}




%
%\todo{}
%acabar de fer més operacions interessants, per exemple una de seqüències, una de funció temporal o un map o fold, etc.

\subsection{Sèries temporals multivaluades i dobles}


\todo{}

No funcionaran a les operacions perquè són operadors de relation {t,v} i les multivaluades són relation{t,relation{v1,v2}} -> potser es podria solucionar amb warps?


\begin{lstlisting}[style=tutorialD]
VAR timeseriesdouble BASE RELATION
    { t1 RATIONAL, v1 RATIONAL, t2 RATIONAL, v2 RATIONAL }  KEY { t1, t2 } ;
\end{lstlisting}


% // multivalued2canonical -> potser es pot fer amb grup/ungroup o wrap/unwrap ?
% //extend r add ( (r rename (t as tr) where t=tr) {ALL BUT tr} as vr ) {t,vr} rename (vr as v)
% //multivalued2canonical
% //r group ({all but t} as v)
% //canonical2multivalued
% // ungroup (v)






\subsection{Quant a definir el tipus sèrie temporal}
\label{sec:implementacio:tipus-relacional}

\todo{}

* Les relacions no són exactament un tipus a Tutorial D però haurien de ser-ho

* S'hauria de poder heretar de les relacions




TYPE ts POSSREP {ts relation {t rational, v rational}};

però després no podríem aplicar-hi operacions relacionals com per exemple el projection perquè és projection(relation)

tampoc podríem definir multivaluades en la forma canònica \verb+ts(relation {tuple {t 1.0, v relation { tuple { v1 1.0, v2 2.0}}}})+ perquè el v no és un rational






La definició estàtica de tipus també dificulta definir tipus i operadors que admetin sèries temporals definides com a relacions on un dels atributs sigui t el temps. Hugh Darwen proposa millores a Tutorial D definit una capçalera com per exemple Relation \{ t Rational, * \} on especificaria un tipus de relació la capçalera de la qual contingui l'atribut temps.
\todo{veure}
Extending Tutorial D to Support User-Defined
Generic Relation and Tuple Operators
Hugh Darwen
File: User-defined relational operators in TD.doc
Printed at: 17:03 on Monday, 18 November, 2013
\url{www.dcs.warwick.ac.uk/~hugh/CHAP05.pdf}
\url{http://www.dcs.warwick.ac.uk/~hugh/TTM/User-defined-relational-operators-in-TD.pdf}


Aleshores podríem definir correctament el tipus sèrie temporal, tot i així encara faria falta que fos un subtipus de relation.

\begin{lstlisting}[style=tutorialD]
type timeseries
	POSSREP canonical {ts relation {t *, v * }}}
	POSSREP multivalued {multivalued relation {t * ,*}} 
	INIT  canonical (multivalued:= ts ungroup (v))
	      multivalued (ts:= multivalued group ({all but t} as v));
\end{lstlisting}

% //Ex
% //with multivalued2(relation{ tuple{ t 1.0, v1 2.0, v2 3.0} }) as r:
% //THE_multivalued2(r)

% //with multivalued2(relation{ tuple{ t 1.0, v1 2.0, v2 3.0} }) as r:
% //THE_ts(r)

% //with ts(relation{ tuple{ t 1.0, v relation { tuple {v1 2.0, v2 3.0}} }}) as r:
% //THE_multivalued2(r)




% \subsection{Pertinença i inclusió}


% with RELATION {
% TUPLE { t 2.0, v 3.0 }
%  } AS m,
% RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 5.0, v 3.0 },
% TUPLE { t 6.0, v 5.0 },
% TUPLE { t 10.0, v 1.0 }
%  } AS ts: 
% ts.in(m,ts)


% \subsection{Màxim i suprem}

% Tutorial D:
% \begin{lstlisting}[style=tutorialD]
% OPERATOR ts.max(s1 SAME_TYPE_AS  (timeseries)) RETURNS RELATION SAME_HEADING_AS  (timeseries);
% return s1 JOIN ( SUMMARIZE s1 {t} PER (s1 {}) ADD (MAX (t) AS t));
% END OPERATOR;

% OPERATOR ts.sup(s1 SAME_TYPE_AS  (timeseries)) RETURNS RELATION SAME_HEADING_AS  (timeseries);
% return ts.max(ts.union(s1,(RELATION { TUPLE {t -1.0/0.0, v 1.0/0.0} })));
% END OPERATOR;
% \end{lstlisting}



% Exemple:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1: 
% ts.max(ts1)
% \end{lstlisting}
% \begin{lstlisting}[style=tutorialD]
% RELATION {
% TUPLE { t 1.0, v 2.0 },
% TUPLE { t 5.0, v 3.0 },
% TUPLE { t 6.0, v 5.0 },
% TUPLE { t 1.0/0.0, v 1.0 }  //1.0/0.0 infinit
%  } AS ts2: 
% ts.max(ts2)
% \end{lstlisting}
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1: 
% ts.sup(ts1)
% \end{lstlisting}
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1: 
% ts.sup(timeseries)
% \end{lstlisting}




% \subsection{Producte}

% with RELATION {
% TUPLE { t 1.0, v 4.0 }
%  } AS s1,
% RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 5.0, v 3.0 },
% TUPLE { t 6.0, v 5.0 },
% TUPLE { t 10.0, v 1.0 }
%  } AS s2: 
% ts.product(s1,s2)


% \subsection{Unió exclusiva}


% TutorialD:
% \begin{lstlisting}[style=tutorialD]
% OPERATOR ts.xunion(s1 SAME_TYPE_AS  (timeseries), s2 SAME_TYPE_AS  (timeseries)) RETURNS RELATION SAME_HEADING_AS  (timeseries);
% return ts.union(s1,s2) MINUS ts.intersect(s1,s2) ;
% END OPERATOR;
% \end{lstlisting}


% Exemple:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1,
% RELATION {
% TUPLE { t 1.0, v 2.0 },
% TUPLE { t 5.0, v 3.0 },
% TUPLE { t 6.0, v 5.0 },
% TUPLE { t 10.0, v 1.0 }
%  } AS ts2: 
% ts.xunion(ts1,ts2)
% \end{lstlisting}


% \subsection{Selecció temporal}



% TutorialD:
% \begin{lstlisting}[style=tutorialD]
% OPERATOR ts.temporal.select.zohe(s SAME_TYPE_AS  (timeseries), l RATIONAL, h RATIONAL ) RETURNS RELATION SAME_HEADING_AS  (timeseries);
% BEGIN;
% VAR x RATIONAL init(0.0);
% VAR sp PRIVATE SAME_TYPE_AS ( timeseries) KEY { t };
% x := ts.v(ts.inf(s MINUS ts.interval.ni(s,h)));
% sp := RELATION {
% TUPLE {t h, v x}
% };
% return ts.union(ts.interval(s,l,h),sp);
% END;
% END OPERATOR;
% \end{lstlisting}

% Exemple:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1,
% RELATION {
% TUPLE { t 1.0, v 2.0 },
% TUPLE { t 5.0, v 3.0 },
% TUPLE { t 6.0, v 5.0 },
% TUPLE { t 10.0, v 1.0 }
%  } AS ts2:
% ts.temporal.select.zohe(ts1,1.0,5.0)
% \end{lstlisting}
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1,
% RELATION {
% TUPLE { t 1.0, v 2.0 },
% TUPLE { t 5.0, v 3.0 },
% TUPLE { t 6.0, v 5.0 },
% TUPLE { t 10.0, v 1.0 }
%  } AS ts2:
% ts.temporal.select.zohe(ts1,-1.0/0.0,-1.0/0.0)
% \end{lstlisting}



% \subsection{Map i fold}



% TutorialD:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
% } AS ts1: 
% ts.map(ts1,'t','t*v/2.0')
% \end{lstlisting}

% TutorialD:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1,
% RELATION {
% TUPLE { t 0.0, v 0.0}
% } AS mi: 
% ts.fold(ts1,mi,'t','v+vi')
% \end{lstlisting}

% antM TutorialD:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1,
% RELATION {
% TUPLE { t 5.0, v 0.0}
% } AS m: 
% ts.sup(ts1 WHERE t < ts.t(m))
% \end{lstlisting}

% sup fold TutorialD:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1,
% RELATION {
% TUPLE { t -1.0/0.0, v 1.0/0.0}
% } AS mi: 
% ts.fold(ts1,mi,'max {t,ti}','v FROM TUPLE FROM (RELATION { TUPLE {t t, v v, e True}, TUPLE {t ti, v vi,  e False} } JOIN RELATION { TUPLE {e t > ti}})')
% \end{lstlisting}

% predecessors mapfold TutorialD:
% \begin{lstlisting}[style=tutorialD]
% with RELATION {
% TUPLE { t 2.0, v 3.0 },
% TUPLE { t 4.0, v 2.0 },
% TUPLE { t 6.0, v 4.0 }
%  } AS ts1,
% EXTEND ts1 {t} ADD ( -1.0/0.0 as v)
% AS si: 
% ts.fold(ts1,si,'t','v FROM TUPLE FROM (RELATION { TUPLE {v ti, e True}, TUPLE {v v,  e False} } JOIN RELATION { TUPLE {e v < ti and ti<t}})')
% \end{lstlisting}


% \section{SGSTM relacional}














%%% Local Variables:
%%% TeX-master: "main"
%%% End:
