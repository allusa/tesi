\lstMakeShortInline[style=py,basicstyle=\sffamily]{@}


\chapter{Implementació amb Python}



La implementació de referència dels models de SGST i SGSTM es realitza
amb Python \parencite{python:doc2}. L'objectiu d'aquesta implementació
de referència és mantenir la fidelitat al model per tal de poder
experimentar-hi amb tota la potència matemàtica .

En la implementació s'afegeixen alguns operadors que en el model no
estaven explícitament definits perquè són propis de l'àlgebra de
conjunts. Alguns dels operadors principals que s'han d'afegir són els
relacionats amb la notació de creació de
conjunts, %set-builder notation (set comprehension)
els quals en els SGBD s'inclouen en el que es coneix com a
\emph{llenguatge de definició de dades} (DDL, de l'anglès \emph{data
  definition language}).
% El model s'ha descrit utilitzant àlgebra de conjunts. Així moltes operacions no s'han hagut de definir perquè formen part de la notació de conjunts: definició de nous conjunts (set builder notation), operació d'assignació, manipulació de les dades amb inserció, modificació, esborrar (perquè en àlgebra de conjunts es treballa amb immutabilitat ja que a l'àlgebra crear un nou conjunt no té cap cost), etc.  A les implementacions, però, totes aquestes operacions s'han de definir en cas que es vulguin.





Implementem els dos models de SGST i SGSTM com a dues biblioteques
diferents: \emph{Pytsms} i \emph{RoundRobinson} respectivament. La
RoundRobinson, però, té una forta dependència en la
Pytsms de la mateixa manera que hem definit els SGSTM en base
als SGST.


Utilitzem orientació a objectes. Ens permet fer explicita la relació
entre la implementació i el model. \todo{més explicat}
Utilitzem diagrames UML per a definir l'estructura de classes. Principalment volem mostrar les relacions entre les diverses classes.\todo{més explicat}
% We design the implementation concepts with object orientation, so that
% there is a clear mapping between model and implementation
% objects. Next we use Unified Modeling Language (UML) diagrams in order
% to define the classes structure, mainly to show the relationships
% among objects.



Implementem la part essencial, és a dir l'àlgebra definida en els
models lògics. No implementem els complements habituals dels SGBD, els
quals són necessaris en entorns d'explotació, com per exemple gestió
d'usuaris i permisos, còpies de seguretat, llenguatges estàndards de
consulta, etc.
Tampoc es tenen en compte paràmetres de rendiment; per exemple no es té en compte si hi ha dues subsèries resolució que tenen el mateix pas de consolidació i les funcions d'agregació d'atributs tenen la mateixa funció de representació --per exemple mitjanaZOHE i màximZOHE\todo{símbols}--,   podrien aprofitar la mateixa operació de selecció temporal d'interval \zohe{}.



\section{Pytsms}

La biblioteca Pytsms implementa un SGST de referència. Així
doncs, seguint el model, els objectes principals són les mesures, les
sèries temporals i les representacions de les sèries temporals. Tots
tres s'implementen respectivament com a classes @Measure@,
@TimeSeries@ i @Representation@.


\begin{figure}[tp]
  \centering
  \begin{tikzpicture}

  %Timeseries
  \umlclass[x=0,y=0] {TimeSeries}{}{}  

  % Measure
  \umlclass[x=-4] {Measure}{}{}
  \umluniaggreg[mult=0..*]  {TimeSeries}{Measure}
  \umlclass[x=-5.2,y=-2] {MFloat}{}{}
  \umlclass[x=-2.8,y=-2] {MChar}{}{}
  \umlinherit {MFloat}{Measure}
  \umlinherit {MChar}{Measure}

  %Repr
  \umlclass[x=4] {Representation}{}{} %,type=abstract
  \umlassoc[mult1=1,mult2=1]  {TimeSeries}{Representation}
  \umlclass[x=3,y=-2] {Zohe}{}{}
  \umlclass[x=5,y=-2] {Delta}{}{}
  \umlinherit {Zohe}{Representation}
  \umlinherit {Delta}{Representation}

  %Associacions visitor
  \umlclass[x=-1.5,y=-4] {RegularProp}{}{}
  \umluniassoc  {RegularProp}{TimeSeries}
  \umlclass[x=1.5,y=-4] {Storage}{}{}
  \umluniassoc {Storage}{TimeSeries}

  %Dependencies
  \umlemptypackage[x=5,y=-5]{Matplotlib}
  \umldep{Zohe}{Matplotlib}
  \umldep{Delta}{Matplotlib}


  \end{tikzpicture}



  \caption{Diagrama UML de Pytsms}
  \label{fig:implementacio:pytsms-uml}
\end{figure}





\begin{figure}
  \centering

\begin{tikzpicture}

  %Timeseries
  \umlclass[x=0,y=0] {TimeSeries}{}{}  
  %Realisations 
  \umlclass[x=-3.5,y=-3] {Structure}{}{}
  \umlclass[x=-1.2,y=-3] {OpSet}{}{}
  \umlclass[x=1.2,y=-3] {OpSeq}{}{}
  \umlclass[x=3.5,y=-3] {OpFunc}{}{}
  %\umlreal[geometry=|-|]{Structure}{TimeSeries}
  \umlinherit[geometry=|-|]{TimeSeries}{Structure}
  \umlinherit[geometry=|-|]{TimeSeries}{OpSet}
  \umlinherit[geometry=|-|]{TimeSeries}{OpSeq}
  \umlinherit[geometry=|-|]{TimeSeries}{OpFunc}
  %Subrealisations
  \umlclass[x=-3,y=-6] {SetNoTemporal}{}{}
  \umlclass[x=0.7,y=-6] {SetTemporal}{}{}
  \umlclass[x=4,y=-6] {SetRelacional}{}{}
  \umlinherit[geometry=|-|]{OpSet}{SetNoTemporal}
  \umlinherit[geometry=|-|]{OpSet}{SetTemporal}
  \umlinherit[geometry=|-|]{OpSet}{SetRelacional}
  \umlclass[x=-6,y=-6,type=python] {set}{}{}
  \umlinherit{Structure}{set}

\end{tikzpicture}

  \caption{Diagrama UML de la realització de sèries temporals a Pytsms}
  \label{fig:implementacio:pytsms-uml-ts}
\end{figure}





La \autoref{fig:implementacio:pytsms-uml} mostra amb un diagrama
UML la relació entre aquests tres objectes principals. Així, per una
banda, una @TimeSeries@ té una relació d'agregació amb les
@Measure@, és a dir que una sèrie temporal conté cap, una o més
d'una mesura.  Per altra banda, les sèries temporals i les
representacions són ortogonals i això s'implementa mitjançant una
relació d'associació bidireccional entre una @TimeSeries@ i una
@Representation@, és a dir que una instància de sèrie temporal té
associada una representació i una instància de representació coneix la
sèrie temporal que representa.




Una @TimeSeries@ és un objecte amb una gran quantitat de
mètodes. Com a conseqüència, la implementació de funcionalitats
essencials s'ha dividit en diversos objectes, els quals es mostren a
la \autoref{fig:implementacio:pytsms-uml-ts}. Els mètodes que
implementen el model estructural i el model d'operacions bàsiques
s'han agrupat en objectes segons la seva funcionalitat. Així hi ha
l'objecte @Structure@ que implementa el model estructural de les
sèries temporals, l'@OpSet@ pel model d'operacions de conjunts,
l'@OpSeq@ pel model d'operacions de seqüències i l'@OpFunc@
pel model d'operacions de funció temporal.  Aleshores l'objecte
@TimeSeries@ multihereta les funcionalitats d'aquests quatre
objectes, cosa que s'implementa a Python com a
\emph{Mixin} \parencite[\S 8.3.6, \S 20.17]{python:doc2}.  L'objecte
@OpSet@ també té una gran quantitat de mètodes i, de la mateixa
manera, hereta la funcionalitat de tres objectes: el
@SetNoTemporal@ per a les operacions basades en l'orde parcial de
les sèries temporals, el @SetTemporal@ basat en l'ordre temporal
i el @SetRelacional@ per a les operacions específiques de
l'àlgebra relacional. Pel que fa a l'@Structure@ hereta
funcionalitats dels objectes @set@, que són un tipus predefinit a
Python \parencite[\S 5.7]{python:doc2}.


Les funcionalitats complementàries de les @TimeSeries@ s'han
implementat amb relacions d'associació unidireccionals, les quals es
mostren a la \autoref{fig:implementacio:pytsms-uml}. Així, hi ha dues
funcionalitats complementàries: @RegularProp@ és un objecte
que agrupa les operacions relacionades amb la regularitat de les
sèries temporals i @Storage@ agrupa les operacions
d'emmagatzematge i de recuperació en fitxers. En aquests casos,
l'associació unidireccional indica que són objectes que treballen
sobre una @TimeSeries@ i s'implementa a Python seguint el patró
de disseny
\emph{Visitor} \parencite[cap.~14]{ziade08:expert_python_programming}. Amb
aquest patró les @TimeSeries@ esdevenen \emph{Visitable}, és a
dir accepten objectes \emph{Visitor} que aporten funcionalitats
extres. Així doncs, els objectes @RegularProperties@ i
@Storage@ són \emph{Visitor}.


La \autoref{fig:implementacio:pytsms-uml} mostra exemples
d'especialitzacions de les mesures i de les representacions.
%
Pel que fa a les @Measure@, poden tenir especialitzacions segons
els tipus dels atributs de temps i de valor. Amb aquesta relació
implementem la propietat homogènia de les sèries temporals i la
definició de mesura indefinida i de valor indefinit, és a dir que
totes les mesures que conté una sèrie temporal són del mateix tipus i
cada tipus de mesura té uns valors de l'atribut temps que la
defineixen indefinida i uns valors de l'atribut valor que la
defineixen de valor indefinit.  Així, per defecte, una @Measure@
defineix els reals $-\infty$ i $+\infty$ per a les mesures indefinida
negativa i positiva respectivament, i defineix el valor @None@ de
Python per a la mesura de valor indefinit. Aleshores, mitjançant
especialitzacions es poden definir altres tipus de mesures; per
exemple la @MFloat@ que defineix el real $\infty$ com a valor
indefinit o bé la @MChar@ que defineix mesures de tipus caràcter.




Pel que fa a les representacions, cada representació en concret és una
especialització de @Representation@. Per exemple @Zohe@ i
@Delta@ implementen la funció de representació \zohe{} i la delta
respectivament.
%\emph{Representation} és una classe abstracta?
Bàsicament, cada representació particular ha de definir l'operació que
calcula l'interval temporal i l'operació que permet trobar-ne el graf.
També cadascuna implementa una operació que dibuixi correctament el
gràfic de la sèrie temporal segons la representació; en les
representacions definides s'usa la biblioteca
\emph{Matplotlib} \parencite{python:matplotlib}  per a fer els gràfics.




\subsubsection{Encaix a Python}

\todo{}

Explicar més detalladament quins mètodes tenen les sèries temporals: unió, selecció, etc.

Heretem de sets, implementem els mètodes especials de sets

implementem els mètodes especials de seqüències







\section{RoundRobinson}

La biblioteca RoundRobinson implementa un SGSTM de referència. Així
doncs, seguint el model, els objectes principals són les sèries
temporals multiresolució, les subsèries resolució, els buffers, els
discs i les funcions d'agregació d'atributs. Respectivament
s'implementen com a classes @MultiresolutionSeries@,
@Resolution@, @Buffer@, @Disc@ i @Function@.
Així, les funcions d'agregació d'atributs són realitzades per
@Function@ de Python.


\begin{figure}[tp]
  \centering

\begin{tikzpicture}

  %MultiTimeseries
  \umlclass[x=0,y=0] {MultiresolutionSeries}{}{}  
  \umlclass[x=-4,y=0,type=python] {set}{}{}
  \umlinherit{MultiresolutionSeries}{set}
  %Components 
  \umlclass[x=0,y=-3] {Resolution}{}{}
  \umluniaggreg  {MultiresolutionSeries}{Resolution}
  %SubComponents 
  \umlclass[x=-1.2,y=-6] {Buffer}{}{}
  \umlclass[x=1.2,y=-6] {Disc}{}{}
  \umlclass[x=-3,y=-9,template={s,i},type=interface] {Function}{}{}
  \umlunicompo[mult=1]  {Resolution}{Buffer}
  \umlunicompo[mult=1]  {Resolution}{Disc}
  \umluniassoc[mult=1]  {Buffer}{Function}

  %Agregadors
  \umlclass[x=-4,y=-12] {mean}{}{}  
  \umlclass[x=-1,y=-12] {mean\_zohe}{}{}  
  \umlinherit{mean}{Function}
  \umlinherit{mean\_zohe}{Function}

  %TimeSeries
  \begin{umlpackage}[x=1,y=-9]{Pytsms}
    \umlclass{TimeSeries}{}{}  
  \end{umlpackage}
  \umluniassoc[mult=1]  {Buffer}{TimeSeries}
  \umluniassoc[mult=1]  {Disc}{TimeSeries}

  %Associacions visitor
  \umlclass[x=4,y=-3] {Storage}{}{}
  \umluniassoc {Storage}{MultiresolutionSeries}
  \umlclass[x=4,y=-1] {Plot}{}{}
  \umluniassoc {Plot}{MultiresolutionSeries}

  

\end{tikzpicture}

  \caption{Diagrama UML de RoundRobinson}
  \label{fig:implementacio:roundrobinson-uml}
\end{figure}



La \autoref{fig:implementacio:roundrobinson-uml} mostra amb un
diagrama UML la relació entre aquests cinc objectes principals. Així,
una @MultiresolutionSeries@ té una relació d'agregació amb les
@Resolution@, és a dir que una sèrie temporal multiresolució
conté subsèries resolucions.  Una @Resolution@ té una relació de
composició amb un @Buffer@ i una altra amb un @Disc@, és a
dir que cada subsèries resolució està formada exactament per un buffer
i un disc. Cada @Buffer@ té una relació d'associació amb una
@TimeSeries@, és a dir amb la sèrie temporal del buffer; de
manera similar per la sèrie temporal del disc cada @Disc@
s'associa a una @TimeSeries@. A més, cada @Buffer@ també té
una relació d'associació amb una @Function@ que ha de tenir dos
paràmetres: la sèrie temporal (@s@) i l'interval de consolidació
(@i@).




Les @MultiresolutionSeries@ tenen funcionalitats complementàries
que s'han implementat amb relacions d'associació
unidireccionals. Així, hi ha dues funcionalitats complementàries:
@Plot@ per a les operacions relacionades amb la visualització
gràfica i @Storage@ per a operacions d'emmagatzematge i de
recuperació en fitxers. Aquests dos objectes també s'han implementat
amb patró de disseny \emph{Visitor} i les @MultiresolutionSeries@
són \emph{Visitable} de la mateixa manera que en el cas de les
funcionalitats complementàries de Pytsms.


Les @MultiresolutionSeries@ com a conjunts formats per
@Resolution@ s'han implementat heretant funcionalitats dels
@set@ de Python. Així, per a definir l'esquema multiresolució hi
ha un mètode @addResolution@ que permet afegir subsèries
resolució. Cadascuna es configura amb quatre paràmetres: @delta@,
@k@, @f@ i @tau@, els quals creen una @Resolution@
amb el @Buffer@ i el @Disc@ corresponent.

Les @MultiresolutionSeries@ tenen mètodes que operen amb totes les
@Resolution@ contingudes. Els més importants són el mètode @add@ per a
afegir noves mesures, el @consolidable@ per a determinar si alguna
subsèrie és @consolidable@ i el @consolidate@ que consolida totes les
consolidables.

Per a les consultes, hi ha dos mètodes: @discSeries@ i @total@. El
@discSeries@ té com a paràmetres @delta@ i @f@ i retorna la
@TimeSeries@ del @Disc@ corresponent. El @total@ retorna la
concatenació de tots els @discSeries@ possibles ordenats per @delta@;
com que no hi pot haver @delta@ repetits, el mètode @total@ té un
paràmetre @f@ que permet seleccionar només aquells @discSeries@ que
tenen unes determinades funcions d'agregació d'atributs.



En un mòdul @aggregators@ hi ha predefinides algunes funcions
d'agregació d'atributs com per exemple @mean@, que agrega la mitjana
d'una sèrie temporal com a conjunt, o la @mean\_zohe@, que agrega la
mitjana seguint la representació \zohe{}.  Això no obstant, els usuaris
en poden definir de pròpies ja que són @Function@ de Python amb els
paràmetres @s@ una @TimeSeries@ i @i@ una parella d'instants de temps
com ara @[t0,tf]@ i que retornen una @Measure@. Per exemple la funció
@mean\_zohe@ retorna una mesura amb @tf@ com a temps i com a valor
l'àrea mitjana a partir la selecció temporal \zohe{} de la sèrie temporal
en l'interval de temps donat.






\section{Exemples d'ús}


Amb les biblioteques Pytsms i RoundRobinson podem treballar amb les
sèries temporals i les sèries temporals multiresolució de manera molt
semblant als models algebraics de SGST i SGSTM.




El \autoref{lst:pytsms:ex1} és un exemple d'ús de Pytsms on
definim dues sèries temporals $s1$ i $s2$ i hi apliquem diverses
operacions: unió, concatenació, interval tancat, interval temporal
\zohe{}, selecció temporal \zohe{} i comprovació de propietats de
regularitat.

\begin{lstlisting}[style=py,caption=Exemple d'operacions amb Pytsms,label=lst:pytsms:ex1]
#Importació dels objectes necessaris
>>> from pytsms import TimeSeries, Measure
>>> from pytsms.representation import Zohe
>>> from pytsms.properties import isRegular

#Definició de les dues sèries temporals d'exemple
>>> s1 = TimeSeries([ Measure(1,1), Measure(3,1), Measure(4,0), Measure(5,1) ])
>>> s2 = TimeSeries([ Measure(2,2), Measure(3,2), Measure(4,0), Measure(6,2) ])

#Manipulacions de les dues sèries temporals
# æ$s1 \cup s2$æ
>>> s1.union(s2)
TimeSeries([m(1,1), m(2,2), m(3,1), m(4,0), m(5,1), m(6,2)])
# æ$s1 || s2$æ
s1.concatenate(s2) 
TimeSeries([m(1,1), m(3,1), m(4,0), m(5,1), m(6,2)])
# æ$s2[2,5]$æ
>>> s2.interval_closed(2,5)
TimeSeries([m(2,2), m(3,2), m(4,0)])
# æ$s2[2,5]^\zohe$æ
>>> s2.interval_temporal(2,5,Zohe)
TimeSeries([m(3,2), m(4,0), m(5,2)])

#Comprovació de la regularitat
# æ$s2$æ no és regular
>>> s2.accept(isRegular())
False
# regularitzem æ$s2$æ amb la selecció temporal æ$s2[{0,2,4}]^\zohe$æ
>>> r2 = s2.selection_temporal(range(0,6,2),Zohe)
>>> r2
TimeSeries([m(0,2), m(2,2), m(4,0)])
>>> r2.accept(isRegular())
True
\end{lstlisting}




El \autoref{lst:roundrobinson:ex1} és un exemple d'ús de RoundRobinson
on definim una sèrie temporal multiresolució $M$, hi afegim una sèrie
temporal $s$, hi apliquem la consolidació i consultem el resultat.

\begin{lstlisting}[style=py,caption=Exemple d'operacions amb RoundRobinson,label=lst:roundrobinson:ex1]
#Importació dels objectes necessaris
>>> from pytsms import TimeSeries, Measure
>>> from roundrobinson import MultiresolutionSeries
>>> from roundrobinson.aggregators import mean_zohe,maximum_zohe

#Definició de sèries temporal d'exemple
>>> s = TimeSeries([Measure(1,6),Measure(5,2),Measure(8,5),Measure(10,0),Measure(14,1),Measure(19,6),Measure(22,11),Measure(26,6),Measure(29,0)])

#Definició de la sèrie temporal multiresolució
>>> M = MultiresolutionSeries()
#Definició de l'esquema multiresolució
>>> M.addResolution(delta=5,k=4,f=mean_zohe,tau=0)
>>> M.addResolution(delta=10,k=2,f=maximum_zohe,tau=0)

#Addició de totes les mesures de la sèrie temporal
>>> for m in s: M.add(m)
#M ja és consolidable
>>> M.consolidable()
True
#Consolidació fins que no sigui consolidable
>>> while M.consolidable(): M.consolidate()

#Consulta æ$seriedisc(M,5,\text{mean}^\zohe)$ææ\glssymbol{not:sgstm:seriedisc}æ
>>> M.discSeries(5,mean_zohe)
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
#Query æ$seriedisc(M,10,\text{maximum}^\zohe)$æ
>>> M.discSeries(10,maximum_zohe)
TimeSeries([m(10,6), m(20,11)])
#Query æ$totalseries(M)$æ
>>> M.total()
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
\end{lstlisting}





\todo{}
Un cas d'exemple és demostrar l'equivalència entre l'operació multiresolució dels SGST sobre una sèrie temporal i la sèrie temporal resultant d'una consolidació dels SGSTM. 




\lstDeleteShortInline{@}
%%% Local Variables:
%%% TeX-master: "main"
%%% End: