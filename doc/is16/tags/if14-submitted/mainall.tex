\documentclass[
%  prepint,
  review,
  twocolumn,
  5p,
  sort&compress,
]{elsarticle}

\journal{Information Systems}


\usepackage{amsmath,amssymb}
\usepackage[pdfborder={0 0 0}]{hyperref}


\usepackage{listings}
\lstdefinestyle{py}{
  language=python,
  escapechar=Ã¦,
  breaklines=true,
  %basicstyle=\ttfamily,
  showspaces=false,
  keepspaces=true,
}


\usepackage{supertabular}





\newcommand{\acro}[1]{\textsc{\lowercase{#1}}}
\newcommand{\R}{\mathbb{R}} % the set of real numbers
\newcommand{\Rb}{\bar\R} % the set of bar real numbers
\newcommand{\N}{\mathbb{N}} % the set of natural
\newcommand{\zohe}{\acro{zohe}}
\newcommand{\dd}{\acro{DD}}

\DeclareMathOperator*{\inst}{\in^t}
\DeclareMathOperator*{\notinst}{\notin^t}
\DeclareMathOperator*{\subseteqt}{\subseteq^t}
\DeclareMathOperator*{\cupt}{\cup^t}
\DeclareMathOperator*{\dift}{-^t}
\DeclareMathOperator*{\join}{join}
\DeclareMathOperator*{\map}{map}
\DeclareMathOperator*{\fold}{fold}
\DeclareMathOperator*{\agg}{aggregate}
\DeclareMathOperator*{\orderfold}{ofold}
\DeclareMathOperator*{\nex}{next}
\DeclareMathOperator*{\prev}{prev}
\DeclareMathOperator*{\graph}{graph}

\DeclareMathOperator{\addB}{addB}
\DeclareMathOperator{\consB}{consB}
\DeclareMathOperator{\addD}{addD}
\DeclareMathOperator{\addR}{addR}
\DeclareMathOperator{\consR}{consR}
\DeclareMathOperator{\addM}{addM}
\DeclareMathOperator{\consM}{consM}
\DeclareMathOperator{\seriedisc}{SerieDisc}
\DeclareMathOperator{\totalseries}{TotalSeries}

\DeclareMathOperator{\dmap}{Dmap}
\DeclareMathOperator{\multiresolution}{multiresolution}

\DeclareMathOperator{\meanz}{mean^\zohe}
\DeclareMathOperator{\maxz}{maximum^\zohe}



\bibliographystyle{elsarticle-num}




\begin{document}



%%PARAMETRES
\newdefinition{definition}{Definition}
\newdefinition{example}{Example}


\begin{frontmatter}

  \title{A new Multiresolution Time Series \\ Database Formal Model}


  \author
  [dipse]
  {Aleix Llus\`{a} Serra\corref{mycorrespondingauthor}
  }
  \cortext[mycorrespondingauthor]{Corresponding author. Tel: +34 938777317}
  \ead{aleix@dipse.upc.edu}

  \author
  [dipse]
  {Sebasti\`{a} Vila-Marta
  }
  \ead{sebas@dipse.upc.edu}

  \author
  [dipse]
  {Teresa Escobet Canal
  }
  \ead{teresa.escobet@upc.edu}



  \address
  [dipse]
  {Department of Electronic System Design and Programming\\ Universitat Polit\`{e}cnica de Catalunya\\ Av.~Bases de Manresa 61--73, 08242 Manresa, ES-CT}



  \begin{abstract}
    In this paper we define a model for multiresolution time series
    database management systems. These systems store each time series
    lossy compressed by extracting different resolutions and attribute
    aggregations. Then time series are stored compactly, with finite
    capacity and with its temporal attribute managed consistently.

    For many applications it is of primary relevance that database
    systems support time series.  We root our theory firmly on set and
    relational algebra together with some time series analysis
    specific properties that can be problematic when manipulating
    them.  Furthermore, we use the time-order acquisition
    characteristic of time series to simplify its treatment by
    stream-like computations in order to achieve fast pre-computed
    queries and visualisations.
  \end{abstract}


  \begin{keyword}
    Time series \sep database systems \sep multiresolution \sep lossy
    compression \sep approximate queries
  \end{keyword}

\end{frontmatter}


%\input{intro}


\section{Introduction}



Information collection processes are growing in quantity as a
consequence of the emergence of embedded systems and sensor networks.
Nowadays it is possible to collect large amounts of data to monitor
and control complex systems.  This information must be analysed and
prepared by information systems in order to detect eventual sensor
failures or malfunctions and, if it is possible, to reconstruct the
incorrect signals. Acquired data instance are bound to a timestamp,
therefore correctness criteria must include both data value and its
timestamp. The sequences of data values collected at specific
timestamps are formalised as time series.


Time series are defined as a collection of observations made
chronologically.  In general, time series come from a continuous
nature in which they are recorded at regular intervals, such as hourly
or daily, or at irregular intervals, such as recording when a pump is
open or closed.  One problem when dealing with time series data
results from the fact that these data are often voluminous
\cite{fu11,keogh08:isax}, as a result, efficiently storing and
accessing them can be complex. Moreover, this is specially critical
when developing small embedded systems, whose resources (capacity,
energy, processing and communications) suffer restrictions
\cite{yaogehrke02}.  Another problem is that the procedure of
processing and synthesising information becomes difficult if data is
not equi-time spaced.



Time series can be stored and managed by Structured Query Language
(\acro{SQL}) relational database management systems. However, some
authors \cite{dreyer94,schmidt95,stonebraker09:scidb,zhang11} notice
that the use of \acro{SQL} systems as a time series backend suffers
some drawbacks.  On the one hand, \emph{NoSQL} or \emph{NewSQL}
products are being developed in order to increase the performance and
flexibility of \acro{SQL} systems
\cite{atzeni13:relational_model_dead,stonebraker10,stonebraker09:scidb,zhang11},
however the continue acquisition nature of time series is an issue for
storing and analysing offline all the data \cite{keogh97}.

On the other hand, compression techniques for time series are
considered in the form of approximation to the original signal in
order to compute analysis such as similarity or pattern search
\cite{fu11,keogh01,last01} or in the form of compression and
aggregation approaches for massive data streams
\cite{cormode08:pods,bonnet01}. However, treating time series as data
streams does not consider adequately the time dimension nor computes
the evolution of aggregated parameters along time, which is
interesting for monitoring purposes.  On a similar approach,
\emph{RRDtool} \cite{rrdtool} is a system that stores time series
aggregated in different resolutions in order to compact data and to do
faster visualisations. However, \emph{RRDtool} is very specific and
has limited aggregation operations to applications of network
counters.



\subsection{Contribution}


%TSMS

This paper focuses on Data Base Management Systems \linebreak[4]
(\acro{DBMS}) that store and treat data as time series, usually known
as Time Series Data Base Management Systems (\acro{TSMS}),
\cite{dreyer94,last01}.  We introduce a new data model named
multiresolution \acro{TSMS} (\acro{MTSMS}). This model organises data
in an aggregated way and  allows to store time series using
different time resolutions. It is designed to cope well with bounded
storage computers such as sensor systems.  

We describe the model in two separated submodels, one \acro{TSMS}
model mainly for describing time series basic concepts and operations
and the other a \acro{MTSMS} model for describing multiresolution over
time series. The model is described firmly rooted on set and
relational algebra as a formal theory for information systems.  It
also considers the time irregularities sampling of time series,
moreover it operates coherently with the time dimension of time
series.



Multiresolution is proposed as a lossy storage solution that selects
only the needed information. The concept is similar to multimedia
lossy compression methods, where information can be discarded in
favour of size, but applied to time series.  Multiresolution is an
aggregation of data that stores the evolution of the parameters along
time, which is more related to the needs of monitoring. However, as a
lossy storage solution, the multiresolution schema has to be decided
for each application, deciding what approximate queries will be needed
to resolve. We formalise aggregation functions as an independent
object of the main model. Therefore, users can define new operations
and other aggregation methods from other fields such as data
streaming or time series data mining.


A representation function concept of time series is also formalised, then
users can define different operators considering the behaviour of time
series in different contexts. Especially, it is important when defining
new aggregation operations that must consider different meanings of
the time series, i.e. \emph{RRDtool} specific counter time series
aggregations. Furthermore, we formalise representation as an
independent object of the main model.




\subsection{Outline}

This manuscript is organised as follows.  In
Section~\ref{sec:related-work} some related work concerning
\acro{TSMS} and \acro{MTSMS} are presented.  The motivation for
multiresolution is shown in Section~\ref{sec:features}.  The
\acro{TSMS} model is presented in Section~\ref{sec:model:TSMS} and the
\acro{MTSMS} model is presented in Section~\ref{sec:MTSMS}.  In
Section~\ref{sec:implementation} there is a implementation
for the \acro{TSMS}+\acro{MTSMS} model.  Section~\ref{sec:example} is
devoted to a real data multiresolution database example.  Finally,
Section~\ref{sec:concl-future-work} offers some conclusions.
\ref{sec:notation} shows main notation symbols.





\section{State of the art}
\label{sec:related-work}

In this section, related work to mutiresolution time series is
described in three parts: some database management systems
approaches for time series, compression techniques applied to time
series, and computations based on data streams.




\subsection{Database approaches}

Some authors treat \acro{TSMS} as a particular \acro{DBMS} field
\cite{last01}.  Segev and Shoshani \cite{segev87:sigmod} propose an
structured language for querying \acro{TSMS}. Their time series
structures include the notion of regularity and temporal
representation and their operations are \acro{SQL}-like.  Dreyer et
al.\ \cite{dreyer94} propose the requirements of special purpose
\acro{TSMS} and base the model on five basic structural elements:
events, time series, groups, metadata and time series bases. They
implement a \acro{TSMS} called \emph{Calanda} which includes calendar
operations, allows grouping time series and operating with simple
queries. They exemplify it with financial data. In \cite{schmidt95}
\emph{Calanda} is compared with temporal systems designed for time
series.



 
Others implement \acro{TSMS} with array database approaches.
\emph{SciDB} \cite{stonebraker09:scidb} and \emph{SciQL}
\cite{zhang11} are array database systems intended for science
applications, in which time series play a principal role. They
structure time series into arrays in order to achieve multidimensional
analysis and they store other data into tables.  \emph{SciDB} is based
on arrays which, according to the authors, allow to represent time
series.  In contrast, \emph{SciQL} defines time series as a mixture of
array, set, and sequence properties and exhibits some time series
managing characteristics that include time series regularities,
interpolation or correlation queries.
% However,
% difference between tables and arrays seems too physical and leads to
% ambiguity when representing time series.  
% Our TSMS model proposes time
% series as firmly based on relational algebra, clarifying this
% ambiguity and describing them coherently in terms of information
% systems theory.





Bitemporal \acro{DBMS}, sometimes referred directly as temporal data,
is a database field related with time. Bitemporal data manages
historical data and events in databases by associating pairs of
\emph{valid} and \emph{transaction} time intervals to data.
Bitemporal data and time series data are not exactly the same and so
can not be treated interchangeably \cite{schmidt95}, however, there
are some similarities that can be considered. Moreover, \acro{DBMS}
research represents bitemporal data as relations extended with time
intervals attributes and extends relational operations in order to
deal with related time aspects
\cite{jensen99:temporaldata,date02:_tempor_data_relat_model}.  We
formalise time series similarly as how bitemporal data is formalised
for relational \acro{DBMS}.
% On the other hand, some bitemporal time concepts might be taken
% into account by \acro{TSMS}, such as the discussions about time
% granularities.



\subsection{Compression techniques}


% As \acro{TSMS} suffer from problematic properties of time
% series, like the ones we describe in
% Section~\ref{sec:model:properties} mainly the huge data volume,
% compression techniques are used.  Next, we summarise some current work
% in \acro{TSMS} with compression.



\emph{RRDtool} from Oetiker, \cite{rrdtool,lisa98:oetiker}, is a free
software database management system. It is designed to be used for
monitoring systems. Because of this, it is focused to a particular
kind of data, gauges and counters, and it lacks general time series
operations. \emph{RRDtool} can store multiple time resolution data,
however Plonka et al.\ \cite{lisa07:plonka} evaluated \emph{RRDtool}
performance and found limitations when storing huge number of
different time series. They propose a caching system on top of
\emph{RRDtool} as a solution.  \emph{RRDtool} is extremely used by the
free software community so it inspired us to develop a model from its
main characteristics, that is now what we call multiresolution. A
similar approach is done by \cite{weigel10} in a system called
\emph{TSDS} that caches queries by aggregate parameters. They notice
that data needs to be shown over its full time range and not only
subsets of data as it is usually provided.  They develop the software
package \emph{TSDS} where time series are stored fully and then
requested by date ranges or by applying different filters and
operations to the time series data.  Our \acro{MTSMS} model is a generic
approach to the multiresolution features, we define it open so that
users can define any attribute aggregate functions.


Deri et al.\ \cite{deri12:tsdb_compressed_database} present
\emph{Tsdb}, a lossless compression storage \acro{TSMS} for time
series that share the same time instants of acquisition. Different
time series are stored grouped by the time of acquisition instead of
each time series isolated.  They compare \emph{Tsdb} with \emph{RRDtool} and
with a relational product. As a consequence of \emph{Tsdb} structure,
they achieve a better measure addition time but a worse global
retrieval time as data has to be contiguously regrouped. However, when
measures have same time this is seen as the same time series in a
\acro{MTSMS}, so it would be interesting to use this implementation
architecture of shared time arrays in \acro{MTSMS} for resolution subseries
with same delta time in order to achieve better performance requirements
when having much equal acquired time series.


There are other lossy compression techniques for time series devoted
to the optimal approximation representation, that is finding the
compromise between least data that can reconstruct the original signal
with least error. Keogh et al.\ \cite{keogh01} cite some possible
approximation representations for time series such as Fourier
transforms, wavelets, symbolic mappings or piecewise linear
representation. They remark this last one as very usual due to its
simplicity and develop a system called \emph{iSAX}
\cite{keogh08:isax,keogh10:isax} in order to analyse and index massive
collections of time series. They describe that the main problem is in
the indexing of time series and they propose methods for processing
efficiently. The first method proposed is based on a constant
piecewise approximation. The time series representation obtained with
\emph{iSAX} allows reducing the stored space and indexing faster with
the same quality as other more complex representation methods.  These
compression techniques are candidates for being used as attribute
aggregate functions in the \acro{MTSMS} model, as instance it would be
interesting to define aggregations in the frequency domain of time
series.


 


\subsection{Data stream}



There are other \acro{TSMS} specifically designed for a particular
field requirements.  \emph{Cougar} \cite{bonnet01} is a sensor
database system that has two main structures: one for sensor
properties stored into relational tables and another for time series
stored into data sequences from sensors. Time series have specific
operations and can combine relations and sequences. \emph{Cougar}
target field is sensor networks, where data is stored distributed in
different locations. Queries are resolved combining sensor data in a
data stream abstraction that improves processing performance.

Time series as data streams are also considered when aggregating
statistically data in order to do fast approximate queries with
compressed data. Cormode et al.\ \cite{cormode08:pods} develop
aggregation techniques that consider giving more weight to recent
information.  Our \acro{MTSMS} model applies a similar approach of
weighting more recent data but specifically to time series, with
multiple aggregations and considering time irregularities.  Dou et
al.\ \cite{dou14:historic_queries_flash_storage} create index
structures as multiresolution aggregates, like average, count, or top,
for historical data managed in flash storage; they consider a specific
storage solution based on register with pointers similar to the
multiresolution storage in \emph{RRDtool} \cite{lisa98:oetiker}.





\section{Multiresolution motivation}
\label{sec:features}

A \acro{TSMS} is a special purpose \acro{DBMS} devoted to store and
manage time series.  The main objective of \acro{TSMS} is to gather
two areas of study: time series analysis and \acro{DBMS}.  Time series
analysis formalises a great amount of algorithms and methodologies
that apply to time series, with a main focus on improving
efficiency. \acro{DBMS} theory formalises systems that store and
operate with data, currently the relational model is the referent
\cite{date:introduction}.



In time series analysis there are some common generic operations.
Most of these operations deal with the time given the nature of data.
Usual operations include querying time intervals, finding time
correlations, or calculating distances between two time series. In
all these operations \acro{TSMS} must consider the temporal coherence
of the time series.  In the context of statistics, aggregation of time
series is also a common operation. Aggregate means to summarise a time
series subset by a smaller set of measures. Statistic indicators like
the mean, the maximum, or the mode, for instance, summarise time
series into one only measure.

In the discrete context, a time series is defined as a set of value
and time pairs. Furthermore, a time series has a continuous nature as
it comes from a phenomena evolution along time. As a result,
\acro{TSMS} operations may deal with this time series nature by
methods of interpolation or approximation.


A \acro{MTSMS} proposes a \acro{TSMS} with multiresolution
capabilities.  A \acro{MTSMS} schema represents a time series using a
set of different resolutions.  The multiresolution concept comes from
thoroughly analysis of \emph{RRDtool} \cite{rrdtool}. Our objectives
have been to formalise the main concepts into an abstract model and to
include more genericity in order to describe \acro{MTSMS} as fully
\acro{TSMS}.



As a summary, \acro{MTSMS} improve \acro{TSMS} features in various aspects:
\begin{itemize}

\item Voluminous data. Monitoring systems capture a huge amount of
  data from sensors. In order to be able to process this information,
  data volume must be reduced. One of the features of the
  multiresolution approach is to select and store only the most
  interesting segments of data. This segments are seen as different
  resolutions for the same time series and the user can configure how
  they are extracted and summarised by defining different time steps
  and functions. Multiresolution can also be useful when graphing time
  series allowing the user to select the best time range and time
  step that fits into the screen; there is no need to process with
  more quantity of data than the one that can be
  shown.

\item Data validation. Monitoring systems capture data but can occur
  some drawbacks that will affect later the process of time series
  analysis. Main problems are found when monitors can not capture
  data, known as gaps, or capture data erroneously, such as outlayers
  \cite{quevedo10}.  The multiresolution attribute functions is
  designed to cope well with validating, filtering and reconstructing
  with this unknown data in order to keep a consistent
  historic.

\item Data time regularising. Another monitoring side effect happens
  when the sampling rate is not constant, that is when the resulting
  data is not equi-time spaced. This no regularities can come from
  sampling jitters in periodic sampling or from no periodic
  event-based sampling \cite{kopetz11:realtime}. One multiresolution
  consolidation objective is to regularise the time interval when
  processing a time series, therefore each resulting time series
  segment has a regular time resolution. This regularising approach
  could also be used when the user wants to consult another resolution
  for a time series, such as changing periodic data from a month to a
  year step.

\item Information summaries. Time series analysis typically focuses on
  reconstructing the original signal. However, the user objective in a
  database system is to consult some information. The multiresolution
  approach allows a lossy compression storage solution for data. Therefore
  it can be regarded as to extracting the interesting information and
  then storing it. The selected information must be determined a
  priori assuming the context where the future queries will be done.
\end{itemize}


However sometimes it may also be useful to complement \acro{MTSMS}
with other \acro{DBMS}. Not only to store the original values as a
long-term deposit consulted offline, but also to store related
information to time series such as units of values, sensor
localisation, classification tags, last measured value, etc.



\subsection{Motivation example}

Figure~\ref{fig:mtsms:sequence} shows an example of a multiresolution
summary for a time series. It shows a snapshot in time, suppose
between time 9 and 10. At the top of the figure there is a plot of a
time series with time axis in general units of time (u.t.) and with
value axis in undetermined units. The 'now' point shows when the
snapshot has been taken, so the time before is the past and the time
after is the future, which is grey coloured. The \emph{init} point
shows when the database system has started sampling, so data in time
before is unknown; the starting point is indicated as zero u.t.\ and
the earlier unknown time points have negative units.


\begin{figure}
  \centering
  %\tikzsetnextfilename{fig_mtsms_sequence}
  %\input{imatges/mtsms_sequence.tex}
  \includegraphics{fig_mtsms_sequence.pdf}
  \caption{Multiresolution snapshot diagram with regular sampling}
  \label{fig:mtsms:sequence}
\end{figure}
%CANVIAR 3 per 2 a la primera mesura de la resolucio 3/mean


At the bottom of Figure~\ref{fig:mtsms:sequence} there is a diagram
showing the multiresolution action. The first row shows the numerical
time series' values corresponding to the above plot; the time series
is sampled every one unit of time. The second and the third row show a
particular schema of a multiresolution database consisting in two time
resolutions for the time series: one computes the mean of the sampled
values every three u.t.\ and the other computes the mean every five
u.t. In this example, computing the mean acts as selecting information
by aggregate statistics. All data stored before zero time is unknown
(\emph{u}) as has not been acquired. For the future values it is also
marked as \emph{u} until time advances.

The arrows of the figure show that every three sampled values a mean
is stored and, independently, every five values another mean is
stored. For the future values, dashed arrows show that if time
advances one u.t.\ then value 10 is sampled and the mean for time 10
can be computed resulting 8 but not yet the mean for time 12.








%\input{model}


\section{Time series model}
\label{sec:model:TSMS}


% In this section we introduce some background concepts and the
% nomenclature which we will use later concerning TSMS. 

Measures and time series are the main objects of \acro{TSMS} and their
main characteristic is that they have a time attribute that requires a
coherent treatment. We describe the \acro{TSMS} nomenclature in three
parts: the data structure model, time series manipulation and
operation, and time series specific properties.



\subsection{Structure}


A \emph{time series} is a set of observations collected at specific
time instants. An observation may consist of a single attribute or
multiple attributes collected at the same time instant.  Each pair of
time and observed values is called \emph{measure}. Then, a time series
is a relation of times with values described as a set of measures .



% Firstly we address time and value concepts and secondly we define formally
% measures and time series.


\subsubsection{Time}

Time, $t$, is an attribute that indicates order between measures. We define
$T$ as the \emph{time domain}. $T$ can be either a finite or an infinite set
and normally it will be a closed set. As an example for the time
domain $T$ we use the affinely extended real numbers $\Rb \in \R \cup
\{+\infty,-\infty\}$ \cite{cantrell:extendedreal}.

The real numbers set is a metric space as it has a distance function
also called metric. Consequently, we can differentiate between time
instants (the elements of the set) and durations (the metric). In this
way, time can be defined as a coordinate system
\cite{iep:time-supplement,kopetz11:realtime} by noting time instants
as points in the real line, durations as segments of the real line,
and specifying a time instant as a reference time. Next, a time
definition is provided that allows to order events, measure events
duration, and position when events happen. This naive approximation
that avoids complex details of the time concept is enough for our
purposes.

\begin{definition}(Time)
  \label{def:model:temps}
  Let $t^i_i$ and $t^i_j$ be two \emph{time instants} with same $t^R$
  as \emph{reference time}, we define the \emph{quantity} or
  \emph{duration of time} $t^d$ as a value $t^d \in\Rb$ which measures
  the distance in time units between two time instants $t^d =
  d(t^i_i,t^i_j)$ where $d$ is the metric of the set $T$. When time
  instants are also real numbers $t^i_i , t^i_j \in \Rb$, then $t^d =
  t^i_i - t^i_j$.

  Let $T$ be the domain for time, we define a \emph{time instant} $i$
  as an element of the set $T$, $i \in T$. Following with the definition of
  a coordinate system and real numbers as time domain, let $t^{R}$ be
  a \emph{reference time instant}, then we define \emph{time instants}
  as a value $t^i \in\Rb$ that measures signed time distance from the
  \emph{reference time instant} $t^i= d(t^{R},i)$. $\square$
\end{definition}

Summarising, time instants position and order events, and between two
time instants there is a duration.  There are several time standards
\cite{allen:timescales} which specify how time duration must be
measured and how time instants positions must be noted.

Time standards deal with a similar concept of time coordinate system
which has been illustrated with real numbers. There is also a calendar
approach which define the time domain with names for the points in the
time line and with rules for time durations. Usually the aim of
calendars is to give a relation between time and Earth
rotation. Sometimes calendars are seen as essential parts of \acro{TSMS}
\cite{dreyer94}, however maps can be established between a time
coordinate system and a calendar system.



\subsubsection{Value}

Value, $v$, is an attribute that indicates the magnitude of measures. The
domain for values can be any data type, that is an object that belongs
to a determined set of values and that has operations associated.
This way valid examples for values are integers, real numbers,
strings, and more elaborated data structures such as arrays, lists, or
even other time series.

%For simplicity
In accordance to the time examples, for the value domain the
projectively extended real numbers $\R* \in \R \cup \{\infty\}$ can be
used.  This example is for scalar values but can be extended to the
concept of multivalues $\R*^n$, which represent a collection of values
measured at the same time instant \cite{assfalg08:thesis}.




\subsubsection{Measure}

A measure associates the concepts of value measured in a particular
time instant.  In a general form, a definition for single values is
given and it can be extended to n-dimensional values.

\begin{definition}
  A \emph{measure} $m$ is defined as a tuple $m=(t,v)$ where $v$ is the
  value of the measure and $t$ is the time instant when the measure
  has been acquired.
\end{definition}

Let $m = (t,v)$ be a measure, $v$ is written as $V(m)$ and $t$ is
written as $T(m)$.


The time attribute defines the canonical order relation between
measures. There are two possible order relations, attending the case
when exists two measures with the same time but different value. Let
$m = (t_m, v_m)$ and $n = (t_n, v_n)$ be two measures.  (i) A
\emph{partial order} is obtained when both measures are equal as a
whole, $m \geq n$ if and only if $t_m > t_n$ or $(t_m, v_m) = (t_n,
v_n)$, as then two measures are not ordered when only $t_m =
t_n$. (ii) A \emph{total order} is obtained when both measures are
equal only considering the time attribute, $m\geq n$ if and only if
$t_m\geq t_n$, as then measures are always ordered.  We also call
\emph{temporal order} to the total order.



\subsubsection{Time series}

Time series are sets of measures of the same phenomena that are
ordered in time.  Sometimes they are also called time sequences
\cite{last:hetland}.


\begin{definition}
  \label{def:model:timeseries}
  A \emph{time series} $S$ is a set of measures $S = \{m_0, \ldots,
  m_k\}$ without repeated time values $\forall i,j:i\neq j: T(m_i)\neq
  T(m_j)$.
\end{definition}

As there are no repeated time values, measures in a time series have a
total order.

Given a time series $S$, its cardinality is noted as $|S|=k+1$.  A
time series without measures is the empty time series,
$S_\emptyset=\emptyset=\{\}$, and has zero cardinality,
$|S_\emptyset|=0$.  Observe that, because measures in $S$ are of the
same phenomena, the type of $S$ values is homogeneous.



A time series can record more than one phenomena if they share the
time instants of acquisition. Then it is a \emph{multivalued time
series}, which can be expressed by two forms. Let $S = \{m_0, \ldots,
m_k\}$ be a time series, in one form we write measures as
$m=(t,(v_1,v_2,\ldots,v_n))$, that is the value has domain $\R*^n$; in
the other form we write measures directly as
$m=(t,v_1,v_2,\ldots,v_n)$.




\subsection{Operations}
\label{sec:model:operations}

Time series have a time attribute that must be manipulated
coherently. Owing to this time attribute, the behaviour of a time
series can be handled on three ways:  set operations including
relational ones,  sequence operations, and  temporal function
operations that manipulate a time series considering it is a
representation for a continuous function. Next a brief description of
most important ones is given.


These time series manipulations are defined abstractly for any time
series having the structure of Definition \ref{def:model:timeseries}.
In the same way as the relational model for operations, definitions
evaluate algebra and logic concepts for data but do not evaluate the
semantics of manipulations. That is, when given a particular context
for a time series manipulation it has to be decided whether the
algebra is meaningful or cannot be applied, for example an addition of
values in two different units could be semantically erroneous.


\subsubsection{Set operations}

We describe how common set operators can be applied to time series. We
rely on how the relational model of DBMS describes operations based on
set algebra \cite{date:introduction}.


In a time series the measures have a total order.  As a time series is
a finite set, if it is not empty it has a maximum and a minimum.  Let
$S$ be a time series and $n\in S$ be a measure, the time series'
\emph{maximum} is $n=\max(S)$ if and only if $\forall m \in S: n \geq
m $.  We extend the maximum definition with a supremum one as for
extended real numbers the supremum is defined even when a set is
empty, $\sup(\emptyset)=-\infty$ \cite{cantrell:extendedreal}. So
applying this property we can say $n=\sup(S)$ is the \emph{supremum}
of the time series where $n=\max(S)$ when defined and
$n=(-\infty,\infty)$ otherwise; note that $V(n)=\infty$ is an
indefinite value.  Dually, we can define \emph{minimum} $\min(S)$ and
\emph{infimum} $\inf(S)$.


In time series binary set operations, the measures can have the
two possible order relations: total and partial. Consequently, this two
possible order relations of measures induces two operation definitions
for some set operators.  Mainly it induces two membership operations
and so to all operations based on it. 


The \emph{membership} defines when one measure belongs to a time
series. Considering the partial order of measures, the set
membership operation applies. Let $S$ be a time series and $m$ a
measure, the \emph{membership} is denoted $m \in S$. Considering the
temporal order of measures, we define the \emph{temporal membership}
as $m \inst S$ when $\exists m_a \in S : T(m) = T(m_a)$.  Let $S_1$
and $S_2$ be two time series, from membership operations we could
define \emph{inclusion} $S_1\subseteq S_2$ and \emph{temporal
  inclusion} $S_1\subseteqt S_2$.


The \emph{union} of two sets is a set containing elements from both
sets. Plain set union operation can not be applied directly as the
resulting time series could have repeated time values.  So we define a
non commutative operation and a commutative temporal operation. The
union requires both time series to have the same structure and type as
happens with union operation in relational \acro{DBMS}
\cite{date:introduction}. %
Let $S_1$ and $S_2$ be two time series. The \emph{union} of both is a
time series $S_1 \cup S_2$ with all measures of $S_1$ and those not
repeated at $S_2$: $S_1 \cup S_2 = \{m^1 \in S_1 \vee m^2 \in S_2 |
m^2 \notinst S_1 \}$. The \emph{temporal union} of both is a time
series $S_1 \cupt S_2$ with all measures from $S_1$ and $S_2$
excluding those that only share the time attribute: $S_1 \cupt S_2 =
\{ m^1 \in S_1 \vee m^2 \in S_2 | m^1 \notinst S_2 \vee m^1 \in S_2,
m^2 \notinst S_1 \}$.

\begin{figure}
  \centering
  %\input{imatges/sgst-union-venn.tex}
  \includegraphics{fig_model_venn.pdf}
  \includegraphics{fig_model_venn2.pdf}
  \caption{Venn diagrams examples for set and temporal set union
    operation of \acro{TSMS}}
  \label{fig:model:venn}
\end{figure}


\begin{example}\label{ex:model:s1s2}
  Let $S_1=\{(1,1),(3,1),(4,0),(5,1)\}$ and $S_2 = \allowbreak
  \{\allowbreak (2,\allowbreak 2),\allowbreak (3,2),(4,0),(6,2)\}$ be
  two time series. The union from first and second results $S_1 \cup
  S_2 = \{(1,1),\allowbreak (2,2),\allowbreak (3,1),\allowbreak (4,
  0),\allowbreak (5,1),\allowbreak (6,2)\}$. The temporal union from
  both results $S_1 \cupt S_2 = S_2 \cupt S_1 =
  \{(1,1),(2,2),(4,0),(5,1),\allowbreak (6,2)\}$. %
  Venn diagrams for both cases are shown in
  Figure~\ref{fig:model:venn}, where the coloured area is the
  resulting time series. For each, the central intersecting area
  indicates measures that share time and value attributes, as instance
  $(2,0)$. The central left area are measures from $S_1$ that only
  share the time attribute with a measure from $S_2$, as instance
  $(3,1)$. Dually the central right area contains $(3,2)$. The left
  and right outer areas are the remaining measures.
 \end{example}




The \emph{difference} of two sets is a set containing all elements
from first not contained in second. Like union, the difference
requires both time series to have the same structure. %
Let $S_1$ and $S_2$ be two time series, the \emph{difference} of first
and second is a time series $S_1 - S_2$ with all measures of $S_1$ not
belonging to $S_2$: $S_1 - S_2 = \{ m \in S_1 | m \notin S_2
\}$. The \emph{temporal difference} of first and second is a time
series $S_1 - S_2$ with all measures of $S_1$ not temporal belonging
to $S_2$: $S_1 -^t S_2 = \{ m \in S_1 | m \notinst S_2 \}$.


Based on union and difference we can define \emph{intersection} $S_1\cap
S_2 \equiv S_1 - (S_1 - S_2)$ and \emph{symmetric difference} $S_1 \ominus
S_2 \equiv (S_1 - S_2) \cup (S_2 - S_1)$ operations as well as its
temporal dual operations.


Relational DBMS extend these set operators with specific ones like
projection, selection, rename, product and join. These operators can
be also used for time series. As example the definition of join
operation is given.


The \emph{join} of two time series is the grouping of pairs that share
the same time attribute in both.  Let $S_1$ i $S_2$ be two time series,
the \emph{join} of both time series $S_1 \join S_2$ is a multivalued
time series $S_1 \join S_2 = \{ (t,v_1,v_2) | (t_1,v_1) \in S_1 \wedge
(t_2,v_2) \in S_2 \wedge t=t_1=t_2 \}$.


\acro{DBMS} need computational operations to be able to compute with
the elements contained in time series. In relational \acro{DBMS} these
operators are extend, aggregate and summarise
\cite{date:introduction}. For time series, we define a more general
equivalent computational operators map and fold.


Map applies a function to each measure of a time series.  Let $S$ be a
time series and $f^m$ a function over a measure where $f^m:m_a\mapsto
m_r$, the \emph{map} of $f^m$ to $S$ is a time series $\map(S,f^m) =
\{\forall m_i\in S : f^m(m_i) \}$.

Fold recursively combines every measures of a time series.  Let
$S=\{m_0, \dotsc, m_k\}$ and $S_i$ be two time series, and $f^f$ a
function over a time series $S_a$ and a measure $m_b$ resulting in a
time series $S_r$, $f^f: S_a \times m_b \mapsto S_r$. The \emph{fold}
of $S$ by $f^f$ with initial value $S_i$ is a time series
$\fold(S,S_i,f^f) = f^f(\dots( f^f(f^f(f^f(S_i,m_0),\allowbreak
m_1),\allowbreak m_2 )\dots),\allowbreak m_k)$.


A simplified fold operation is \emph{aggregate} which is used for
combining a time series into one measure, normally it is used to
compute aggregate statistics.  Let $S$ be a time series, $m_i$ a
measure, and $f^a$ a function over two measures where $f^a: m_a \times
m_b \mapsto m_r$.  Based on fold operation \emph{aggregate} can be
defined as: $\agg(S,m_i,f^a) \equiv \fold(S,\{m_i\},f')$ where $f':
\{m_i\} \times m \mapsto \{f^a(m_i,m)\}$.

%A more generic version of fold is a fold considering order. 
In the previous fold the measures are computed in random order,
however in some computational operations it is necessary to define the
order, especially when $f^f$ is not commutative. We define a
\emph{fold with order}, $\orderfold$, as an extension of fold with a
function $o$ that selects measures in order where $o: S_a \mapsto m_r$
\[
 \orderfold(S,S_i,f^f,o) =
  \begin{cases}
    S_i  \text{ if } |S|=0, \\
    \orderfold(S_o,f^f(S_i,m_o),f^f,o)  \text{ otrw.}
  \end{cases}
\]
where $m_o = o(S)$ and $S_o = S - \{m_o\}$.


Finally, we describe how \emph{binary computational} operations can be
defined for two time series in order to operate with their value
attributes.  First it is required to join the two time series and then
apply computational operations. Let $S_1$ and $S_2$ be two time series
and \emph{op} be a binary operation on the value domain, that is for
two values $v_1$ and $v_2$ it computes a new value $\operatorname{op}:
v_1 + v_2 \mapsto v'$. The operator \emph{op} can be applied to both
time series as: $\operatorname{op}: S_1 \times S_2 \mapsto S'$ where
$S' = \map(S_1 \join S_2, (t,v_1,v_1)\mapsto(t,v_1 \operatorname{op}
v_2))$.

For example, we can apply real numbers binary operations such as sum,
$S_1 + S_2$, or division, $S_1 / S_2$. It must be noted that join
requires both time series to have exactly the same time
attribute. When time series diverge too much then temporal function
operations can be applied to fit the time instants to what is
required.





\subsubsection{Sequence operations}

Sequence operations manipulate time series considering measures as
being totally ordered. Then three basic operations can be defined:
interval, successor and concatenation.


The \emph{interval} $(t_i,t_f)$, where $t_i$ and $t_f$ are two time
instants, over a time series $S$ is a time subseries between the two
time instants $S(t_i,t_f) \subseteq S$. A similar interval concept
is used by \cite{last:hetland}. The open interval is defined as
$S(t_i,t_f)=\{m\in S | t_i<T(m)<t_f\}$. Other intervals can be
defined: closed $S[t_i,t_f]$, left-open $S(t_i,t_f]$, and right-open
$S[t_i,t_f)$.

The time order in time series also implies the sequence concept of
\emph{successor} and \emph{predecessor}.  Let $S=\{m_0, \ldots, m_k\}$
be a time series and $m_S\in S$ and $m_a$ be two measures. We say
$m_S=\nex_S(m_a)$ is the \emph{next} measure to $m_a$ in $S$ if and
only if $m_S=\inf(S(T(m_a),+\infty])$.  We say $m_S=\prev_S(m_a)$ is
the \emph{previous} measure to $m_a$ in $S$ if and only if
$m_S=\sup(S[-\infty,T(m_a)))$. %
Infinite measures are obtained when next and previous are applied to
supremum and infimum measure respectively: $\nex_S(\sup
S)=(+\infty,\infty)$ and $\prev_S(\inf S)=(-\infty,\infty)$.



\emph{Concatenation} comprises the measures of the first time series
followed in time order by the measures of the second. It is similar to
union for sets but considering the sequence interval. The
concatenation requires both time series to have the same structure as
seen with union operation.  Let $S_1$ and $S_2$ be two time series,
the concatenation of both $S_1 || S_2$ is a time series $S$ containing
all measures of $S_1$ and those of $S_2$ that not intersect in the
time interval of $S_1$.  $S_1 || S_2 = S_1 \cup ( S_2 - S_2[t_1,t_2]
)$ where $t_1=T(\inf S_1)$ and $t_2=T(\sup S_1)$.



\subsubsection{Temporal function operations}
\label{sec:model:tfunc}

A time series is a discrete representation of a continuous function,
more precisely a temporal continuous function as time is the function
domain. Operations that manipulate time series according to this
temporal function nature can be defined.

The \emph{graph of a function} allows to obtain and interpret the
continuous nature of a time series, when the domain of time and value
attributes can be plotted then the graph is equivalent to a graphical
representation.  Let $S$ be a time series and $T$ the time domain, the
\emph{graph} of the time series is a set of ordered pairs $\graph S =
\{ (t,S(t)) | t\in T \}$ where $S(t)$ is a temporal representation
function for the time series.

The \emph{temporal representation function} $S(t)$ is a continuous
function along variable $t$ in the domain of time and the target in
the domain of values. $S(t)$ can be obtained by various methods, so
there are several possible temporal representation functions. In all
temporal function operations a superscript $r$ indicates the name $r$
of the representation method used, as instance $S(t)^r$ is the
representation function using method $r$. We exemplify the
representation functions using two methods $r$ based on impulse and
constant piecewise functions.


\begin{definition}
  \emph{Dirac delta} (\dd) is a method of representation based on the
  Dirac delta function. It is an impulse train function that is zero
  everywhere except at zero.  Let $S$ be a time series we define
  $S(t)^\dd$ as the \emph{\dd{} representation function}
\[
    \forall m \in S: S(t)^\dd
    =  \begin{cases}
      V(m) & \text{if }  t=T(m) \\
      0 & \text{otherwise}
    \end{cases}
\]
\end{definition}

\begin{definition}
  \emph{Zero-order hold everted} (\zohe{}) is a method of
  representation based on the \emph{zero-order hold} signal
  reconstruction methods. It is a piecewise constant function that has
  left-continuous step functions.  Let $S$ be a time series we define
  $S(t)^\zohe$ as the \emph{\zohe{} representation function}, $\forall
  m \in S:$
\[
    S(t)^\zohe 
    = \begin{cases}
      0 & \text{if }  t > T(\max(S)) \\
      V(m) & \text{if } t\in \big(T(\prev_S(m)),T(m)\big]
    \end{cases}
\]
\end{definition}




The concept of representation is used for formalising some set and
sequence operators as temporal operators. 

%Consequently, the result of each one will depend on a representation method, which is indicated as a parameter.


We define a temporal interval operation to introduce this
concept.
Let $S$ be a time series, $[t_i,t_f]$ a interval of two time instants
and $r$ a representation function. The \emph{temporal interval} noted
as $S[t_i,t_f]^r$ is a time series with measures in the interval
temporal range: $S[t_i,t_f]^r= \forall t \in [t_i,t_f] : S' = S(t)^r
$. This is a general definition difficult to implement, so for every
representation a particular temporal interval must be interpreted:

\begin{itemize}
\item Let $S(t)^\dd$ be the \dd{} representation for $S$, the
  \emph{\dd{} temporal interval} is $S[t_i,t_f]^\delta = S[t_i,t_f]
  \cup \{m_0\} \cup \{m_f\}$ where $m_0=(t_i,0)$ and $m_f=(t_f,0)$.

\item Let $S(t)^\zohe{}$ be the \zohe{} representation for $S$, the
  \emph{\zohe{} temporal interval} is $S[t_i,t_f]^\zohe{} = S(t_i,t_f]
  \cup \{m\}$ where $m=(t_f,v)$ and $v= V(\inf( S[t_f,+\infty] ))$.
\end{itemize}



From temporal interval other operators can be defined such as temporal
selection, temporal concatenation, or temporal join. As example the
definition of temporal interval operation is given.


The temporal selection over a time series allows to change the
resolution in the context of a representation function.  Let $S$ be a
time series, $i=\{t_0,t_1,\dotsc,t_n\}$ a set of time instants, and
$r$ a representation function. The \emph{temporal selection} noted as
$S[i]^r$ is a time series with measures in $i$ times computed in
coherence with the representation function $r$: $S[i]^r = S[t_0,t_0]^r
\cup S[t_1,t_1]^r \cup \dotsb \cup S[t_n,t_n]^r$. Let $t_a$ be a time
instant, note that temporal selection depends on the temporal interval
operation $S[t_a,t_a]^r$, which is equivalent to the notion of
temporal representation function over an argument as $S[t_a,t_a]^r
\equiv \{ (t_a, S(t_a)^r) \}$.





\subsection{Properties}
\label{sec:model:properties} 

In the acquisition of data it is difficult to obtain ideal times
series as described. Following we note some properties of time series
that can be problematic when manipulating them.

First, clock is a crucial measuring instrument in time
series. Precision and accuracy is very important in timestamps.  In
\cite{kopetz11:realtime} these concepts are well described as well as
solving methods, especially clock synchronisation methods.


Second, unknown data can corrupt the database. Unknown data appears
when data has not been captured or when it has been acquired
erroneously. Then data validation must be performed, which can result
in rejecting new values if they are not correct or in reconstructing
this erroneous data.  Data validation process has to consider when
values are outside the possible range domain, when there has not been
possible to acquire a sample, when the time of acquisition between
measures is not considered freshness, etc. \acro{MTSMS} is designed to
cope with this data validation process with the help of time series
representation functions such as \zohe{}.


Third, enormous quantity of data difficults computations.  Time series
come from data recollected at monitoring systems and so its size gets
very big as continuously new measures are added.  \acro{MTSMS} is
designed to be an storage solution with data size reduction by using
time series aggregate operations.


Forth, sample period irregularities difficult later time series
analysis. That is when data has not been acquired uniformly at time it
is harder to apply join operations between time series and it do not
allow to apply time series analysis algorithms defined for sequences
approaches.  \acro{MTSMS} tries to storage regular time series in the
process of consolidation.  Next we detail the regular concept for time
series.


A time series is regular when its measures are equi-spaced in time,
according to \cite{last:hetland}. Let $S$ be a time series, $t_I$
be a time instant and $d$ be a time duration, then the time
series' measures can be located in the time interval $i_0=[t_I,
t_I+d]$ and its multiples $i_j=[t_I+jd, t_I+(j+1)d]$
for $j=0,1,2,\ldots$. When time series' measures are equally spaced we
say it to be regular.

\begin{definition}
  Let $S=\{m_0,$ $\ldots,$ $m_k\}$ be a time series and $d$ a time
  duration. $S$ is \emph{regular} if and only if $\forall m \in
  S(T(\min(S),+\infty):T(m) - T(\prev_S(m)) = d$.
\end{definition}


If a time series is not regular, it can be regularised by the temporal
selection operation. Let $S$ be a time series, $t_I$ and $d$ the
desired regularity parameters, and $k\in\N$ a limit for the scope of
the range.  A regularised $S$ is obtained with $S[i]^r$ where $i =
\{t_I+jd | d\in\N, d\leq k \}$ is a set of time instants equi-spaced.





\section{Multiresolution model}
\label{sec:MTSMS}


The \acro{MTSMS} are \acro{TSMS} that store time series with a lossy
compression approach, that is some information is selected and spread
in different time resolutions. The \acro{MTSMS} model is based on the
concepts of measures and time series as defined in
Section~\ref{sec:model:TSMS} and we call multiresolution time series
to each time series stored in a multiresolution database
(\acro{MTSDB}).


The architecture of \acro{MTSMS} model for one multiresolution time series is
shown in Figure~\ref{fig:model:mtsdb} depicted with its main
components.  A multiresolution time series is a collection of
resolution subseries which temporarily accumulate measures in a buffer
in order to select some information and finally store it in a
disc. The information selection process changes the time intervals
between measures to compact information by aggregating the time series
attributes.

%\tikzsetnextfilename{fig_model_mtsdb}
\begin{figure}
  \centering
  %\input{imatges/mtsms-arquitectura_interna.tex}
  \includegraphics{fig_model_mtsdb.pdf}
  \caption{Architecture of \acro{MTSMS} model}
  \label{fig:model:mtsdb}
\end{figure}


In this way, the original time series gets stored spread in the discs,
each with a different time resolution and attribute aggregation.
Discs are size bounded so they only contain a fixed amount of
measures. When a disc becomes full it discards a measure. Thus,
multiresolution database is bounded in size and the time series gets
stored in pieces, that is time subseries.

Regarding operations, \acro{MTSMS} structure needs operators to change
the time intervals between measures and to select attributes. Mainly,
these operators are measure additions and time series consolidations,
which some functionality is delegated to operators called attribute
aggregate functions. Secondarily, there are operators to query the
multiresolution schema and extract time series data.


Following we define the \acro{MTSMS} model structure and structural
operators, the operations to query a multiresolution schema, and
attribute aggregate functions.  Furthermore, schema manipulation
operations could be defined but we focus on structure and data query .


\subsection{Structure}

A \emph{buffer} is a container for a regular or a no-regular time
series. The buffer objective is to regularise the time series using a
predetermined step and an attribute function. We name
\emph{consolidation} to this action.
\begin{definition}%(Buffer)
  A \emph{buffer} is defined as the tuple $(S_B,\tau,\delta,f)$ where
  $S_B$ is a time series, $\tau$ is the last consolidation time,
  $\delta$ is the duration of the consolidation step and $f$ is an
  attribute aggregate function.

  An empty buffer $B_{\emptyset} = (\emptyset,t_0, \delta, f)$ has an
  empty time series, an initial consolidation time $t_0$ and
  predetermined $\delta$ and $f$.
\end{definition}

Operator \emph{addBuffer} adds a measure to its time series:
$\addB: B = (S_B,\tau,\delta,f) \times m \mapsto
(S'_B,\tau,\delta,f)$ where $S'_B = S \cup \{m\} $.

From the $B_{\emptyset}$ all the consolidation time instants can be
calculated as $t_0+i\delta, i\in\N$. The consolidation of $B$ in a
time interval $i=[\tau,\tau+\delta]$ results in a measure
$m'=f(S_B,i)$ where $f$ is an attribute aggregate function
$f$. Operator \emph{consolidateBuffer} consolidates a set of measures
and removes the consolidated part of the time series from the buffer:
$\consB : B=(S_B,\tau,\delta,f) \mapsto B' \times m'$ where $ B'=
(S'_B,\tau+\delta,\delta,f)$, $m' = f(S,[\tau,\tau+\delta])$, and
$S'_B$ is the discarding of historic data not needed anymore, for example
$S'_B = S[\tau+\delta,+\infty]$.

On a simplified way, the \emph{consolidateBuffer} is only applied to the present
consolidation interval and the total consolidation is obtained by
successive application of the operator. This requires measures to be
added by time order and to consolidate the buffer when the time of
some measure is bigger than the buffer's next consolidation time.  Let
$B=(S_B,\tau,\delta,f)$ be a buffer and $m=\sup(S_B)$ the maximum
measure, $B$ is consolidable if and only if $T(m) \geq
\tau+\delta$.


A \emph{disc} is a finite capacity measures container. A time series
stored in a disc has its cardinal bounded. When the cardinal of the
time series is to overcome the limit, some measures need to be
discarded.
\begin{definition}%(Disc)
  A \emph{disc} is a tuple $(S_D,k)$ where $S_D$ is a time series and
  $k\in\N$ is the maximum allowed cardinal of $S_D$.  An empty disc
  $D_{\emptyset} = (\emptyset,k)$ has an empty time series and $k$ is
  the maximum cardinal allowed.
\end{definition}

The cardinal of the times series is kept under control by the add
operator, $\addD : D=(S_D,k)\times m\mapsto (S'_D,k)$ where %
$
 S_D' = \begin{cases}
  S_D\cup\{m\}                 & \text{if } |S_D|<k  \\
  (S_D-\{\min(S_D)\}) \cup \{m\} & \text{otherwise}
\end{cases}  
$.


A \emph{resolution subseries} is a structure that regularises and
aggregates a time series. It is composed of a buffer, that contains
the partial time series to be regularised, and a disc, that contains
the regularised time series.
\begin{definition}%(Resolution subseries)
  A \emph{resolution subseries} is a tuple $(B,D)$ where $B$ is a
  buffer and $D$ is a disc.  An empty buffer and empty disc imply an
  empty resolution subseries $R_{\emptyset} =
  (B_{\emptyset},D_{\emptyset})$.
\end{definition}
 
The operators of a resolution subseries extend the buffer and disc
ones: (i) The addition of a measure to the buffer of the resolution
subseries: $\addR : R=(B,D) \times m \mapsto R'$ where $R'= (B',D)$,
and $B'= \addB(B,m)$; (ii) The consolidation of the resolution
subseries by consolidating its buffer and adding the consolidation
measure to its disc: $\consR : R=(B,D) \mapsto R'$ where $R'=
(B',D')$, $(B',m') = \consB(B)$, and $D'= \addD(D,m')$.  A resolution
subseries is consolidable only when its buffer is consolidable.




A \emph{multiresolution time series} is a set of resolution subseries
which share the input of measures, that is the same time series. A
time series is stored regularised and distributed with different
resolutions in the various resolution subseries, as previously shown
in Figure~\ref{fig:model:mtsdb}.
\begin{definition}%(Multiresolution time series)
  A \emph{Mul\-ti\-re\-solution time series} is a set of resolution
  subseries $\{R_0, \dots, R_d\}$.  An empty multiresolution series
  has empty resolution subseries $M_{\emptyset}=\{R_{0_\emptyset},
  \dots, R_{d_\emptyset}\}$. Usually there are no repeated pairs of
  ($\delta_i$,$f_i$) among a multiresolution series, so they act as a
  key attributes.
\end{definition}

Therefore, defining a multiresolution time series consists basically
in defining the quantity of resolution subseries and the
$(\delta,\tau,f,k)$ configuration parameters of each.


The operators of a multiresolution time series apply to every
resolution subseries contained: (i) The addition of a measure to every
resolution subseries: $\addM : M=\{R_0,\allowbreak \dots,\allowbreak
R_d\} \times m \mapsto \{R'_0, \dots,\allowbreak R'_d\}$ where
$R'_i=\addR(R_i,m)$; (ii) The consolidation of all resolution
subseries: $\consM : M=\{R_0,\allowbreak \dots,\allowbreak R_d\}
\mapsto \{R'_0,\allowbreak \dots,\allowbreak R'_d\}$ where $R'_i =
\consR(R_i)$ if $R_i$ $\text{ consolidable}$ and $R'_i=R_i$
$\text{otherwise}$.


The multiresolution consolidation operation should be applied
regularly based on a consolidation clock. When the measure ordered
addition approach is taken as explained in the buffer's consolidation,
then there is no need for a clock in a \acro{MTSMS}. The consolidation clock
is induced by the measure's addition and then it is only necessary to
check the multiresolution consolidation operation on new
additions. However, there could be other approaches where the
consolidation clock was given by an external clock or external
events. Then the consolidable definitions would depend on this
external clock.





\subsection{Queries}


There are two basic time series queries for a \acro{MTSMS}: (i) extract a
time subseries from a resolution subseries' disc or (ii) query for a
total time series from all consolidated information.

The first is a selection of a disc over a multiresolution time series,
being $(\delta,f)$ the key attributes: $\seriedisc: M=\{R_0, \dots,
R_d\} \times \delta \times f \mapsto S'_D \in D' | (B',D') \in R',R' \in
M$.

The second is a concatenation of all discs' time subseries trying to
obtain the most resolution as possible, which is to say by $\delta$
order: $\totalseries: M*=\{R_0, \dots, R_d\} \mapsto S'$ where $S' =
S_{D0} || S_{D1} || \cdots || S_{Dd}$ and $\delta_0 < \delta_1 <
\cdots < \delta_d$. This states that $M*$ is a multiresolution time
subseries where $R_i$ have a total order by its attribute
$\delta_i$. Being $(\delta,f)$ the key attributes, the $M*$ can
be obtained from $M$ by selecting resolution subseries with same $f$. If we
operated a $\totalseries$ to a general $M$ then it could be ambiguous
as it could contain repeated $\delta_i$.


From these two basic time series queries, more elaborated queries can
be applied to \acro{MTSMS} by using \acro{TSMS} operations. For
example, let $M_1$ and $M_2$ be two multiresolution time series, we
can compute the sum of both with $\totalseries(M_1) +
\totalseries(M_2)$.
% This is the general algebraic expressions that describes the model,
% but an implementation of the model could accomplish this operation
% in a more efficient way.





\subsection{Attribute aggregate function}
\label{sec:model:interpolador}

Attribute aggregate functions are a specific case of \acro{TSMS} aggregate
operation which summarise time series information when consolidating a
buffer. Let $S$ be a time series and $t_0$ and $t_f$ two time
instants, an attribute aggregate function $f$ calculates a measure
that summarises the measures of $S$ included in the time interval
$i=[t_0,t_f]$:
\[
f : S=\{m_0,\ldots,m_k\} \times i=[t_0,t_f] \mapsto m'
\]
where, generally, $m'$ results from two operations on the time series:
(i) a time subseries selection $S'$ depending on the consolidating
interval, for example $S' = S[t_0,t_f]$, and (ii) a \acro{TSMS} aggregation
over this time subseries such as $m' = \agg(S',m_i, f^a)$ where $f^a$
is a function over two measures.


Many different attribute aggregate functions can be used in order to
summarise a time series, for example it is possible to calculate an
statistic indicator of the time series such as the average or a more
complex digital signal processing operation
\cite{zhang11}. Furthermore, the representation for a time series and
some of its pathologies can be considered during the aggregation
process.


As it is possible to define many attribute aggregate
functions no global assumptions can be made about them. Each user has
to decide which combination of aggregation and representation fits
better with the measured phenomena.  Therefore, \acro{MTSMS} has to be
designed for allowing users to define aggregate functions.





Regarding the resulting consolidation time, normally it will be
$T(m')=t_f$ to be consistent with the consolidation operation of a
buffer where $\tau' = \tau + \delta \equiv t_f$. However $T(m')$ can
have a time offset with the buffer consolidating times, as instance
the resulting measure can be aggregated from a time subseries $S'$
with open interval $S'=S(t_0,t_f)$, closed interval $S'=S[t_0,t_f]$,
or other combinations like $S'=S(t_0-d,t_f-d]$ where $d$ is a time
duration.  The time offset can also be variable, as for example an
aggregate function that returns the first measure of the interval
$S[t_0,t_f)$, $m'=\min(S[t_0,t_f))$, then the resulting time can be
between $t_0 \leq T(m') < t_f$.


Attribute general patterns can be defined that explain how the
resulting value $V(m')$ is calculated, letting the resulting time
instant $T(m')$ subject to interpretation.  Next there are some
attribute patterns examples based on temporal function time series
operators, that is the time series aggregated corresponds to a
continuous function $S(t)^r$ where $r$ is a representation as has been
described in Section~\ref{sec:model:tfunc}. The patterns of these
functions leave $T(m')$ undefined as well as the representation $r$ of
the time series. Let the time be continuous on all the time domain
$t\in T$:
\begin{itemize}
\item maximum$^r$: $S \times i \mapsto m'$ where $V(m') =
  \max\limits_{\forall t \in i}(S(t)^r)$. It summarises $S$ with the maximum
  of the measure values in the interval $i$.
\item last$^r$: $S \times i \mapsto m'$ where $V(m') = S(t_f)^r$. It
  summarises $S$ with the value at $t_f$ time instant.
\item mean$^r$: $S \times i \mapsto m'$ where $V(m') =
  \frac{1}{t_f-t_0} \int\limits_{t_0}^{t_f} S(t)^r dt$. It summarises $S$
  with the mean of the function in the interval $i$.
\end{itemize}


These aggregation function patterns can be expressed with discrete
mathematics for each particular representation, that is based on the
temporal interval defined in Section~\ref{sec:model:tfunc}. Next we
exemplify it by interpreting the general continuous patterns for two
particular representations that have been defined previously: \dd{}
and \zohe{}.


Dirac delta attribute aggregation functions $f^\dd$ have a general
form $f^\dd : S \times [t_0,t_f]\mapsto m'$ where $m'=(t',v')$, the
resulting time is interpreted as centred on the interval
$t'=\frac{t_f+t_0}{2}$ and the resulting value depends on the
attribute, let $S'=S[t_0,t_f]^\dd$ be the selection of measures by
Dirac delta temporal interval:
\begin{itemize}
\item maximum$^\dd$: $v' = \max\big(0,\max_{\forall m \in S'}(V(m))\big)$. 
\item last$^\dd$: $v' = \max(S')$.
\item mean$^\dd$: $v' = \frac{1}{t_f-t_0} \sum\limits_{\forall m
    \in S'} V(m)$, as Dirac delta function has property $\int\dd(t)dt=1$.
\end{itemize}


\zohe{} attribute aggregation functions $f^\zohe{}$ have a general
form $f^\zohe{} : S \times [t_0,t_f]\mapsto m'$ where $m'=(t',v')$,
the resulting time is interpreted as right limit of the interval
$t'=t_f$ and the resulting value depends on the attribute, let
$S'=S[t_0,t_f]^\zohe{}$ be the selection of measures by \zohe{} temporal
interval:
\begin{itemize}
\item maximum$^\zohe{}$: $v' = \max_{\forall m \in S'}(V(m))$. 
\item last$^\zohe{}$: $v' = \max(S')$.
\item mean$^\zohe{}$: $v' = \frac{1}{t_f-t_0} \big[ (T(o)-t_0)V(o) +
  \sum\limits_{\forall m \in S''}( T(m)- T(\prev_S
  m) )V(m) \big]$ where $o=\min(S')$ and $S''= S' - \{o\}$.
\end{itemize}

A similar aggregation function to mean$^\zohe{}$ is used by \emph{RRDtool}
\cite{rrdtool} in order to summarise information for velocity coun\-ter
data by keeping the total counting information, as mean aggregation
can be seen as one keeping the area below the original signal.


In conclusion, some patterns are very similar. As instance maximum and
last attributes differ basically on the interval selection
operation. However, other patterns have a more elaborated
interpretation in a particular representation. As instance
mean$^\zohe{}$ and mean$^\dd$ are an elaborated interpretation for
the general integral definition.





\begin{example}\label{ex:model:smultiresolution} 
  We define a multiresolution schema for a time series, we consolidate
  the database and we query its information.  Let $S = \{
  (1,6),(5,2),\allowbreak (8,5),\allowbreak (10,0),\allowbreak
  (14,1),\allowbreak (19,6),\allowbreak (22,11),\allowbreak
  (26,6),(29,0) \}$ be a time series and $M_\emptyset=\{R_0,R_1\}$ a
  multiresolution time series where each resolution parameters are
  $\tau_0=0$ , $\delta_0=5$, $f_0 =\meanz$, $k_0=4$ and $\tau_1=0$,
  $\delta_1=10$, $f_1 =\maxz$, $k_1=2$. Therefore $R_0$ will be
  consolidated at time instants 5, 10, 15, 20, 25, 30\dots and $R_1$
  at 10, 20, 30\dots

  All measures of $S$ are added to $M_\emptyset$
  and then it is consolidated until it is no more consolidable. As
  $T(\max(S))=29$, the last consolidation times are $\tau_0=25$ and
  $\tau_1=20$, so we call $M_{29}$ to this multiresolution time series
  at this state.

  Then the two time subseries consolidated are obtained by querying
  $\seriedisc(M_{29},5,\allowbreak \meanz)=\{(10,3),\allowbreak
  (15,\allowbreak 2),\allowbreak (20,7),\allowbreak (25,8)\}$ and
  $\seriedisc(M_{29},10,\allowbreak  \maxz) =\allowbreak \{ \allowbreak
  (10,6),\allowbreak (20,11)\}$. Regarding buffers, note that
  $S_{B0_{29}}= \{\allowbreak (26,6),\allowbreak (29,0)\allowbreak \}$
  and $S_{B1_{29}}=\{\allowbreak (22,11),\allowbreak (26,6),(29,0)\}$.

  In this particular example
  $ \totalseries(M_{29}) = \seriedisc(M_{29},\allowbreak 5,\meanz)$ as $R_0$ has
  double resolution than $R_1$. $\square$
\end{example}





%\input{implementation}


\section{Referent implementation}
\label{sec:implementation}

We implement the \acro{TSMS} and \acro{MTSMS} models with Python
\cite{python:doc2} programming language. It is a referent
implementation in order to show how a system can be developed from the
models, therefore it has fidelity to the algebraic model defined in
Section~\ref{sec:model:TSMS} and \ref{sec:MTSMS} but has not extended
\acro{DBMS} components, as would be query optimisation or
transaction management.

The two models of \acro{TSMS} and \acro{MTSMS} are implemented
respectively as two separated Python libraries: Pytsms and
RoundRobinson.  RoundRobinson has a strong dependency on Pytsms
following the \acro{MTSMS} being defined based on \acro{TSMS}.  The
code of this implementation can be found at
\cite{llusa:roundrobinson}.

We design the implementation concepts with object orientation, being a
clear mapping between model and implemented objects. Unified Modeling
Language (\acro{UML}) diagrams are used for defining the classes
structure, mainly to show the relationships among objects.  Operations
are implemented as object methods, which are not show in \acro{UML}
diagrams for space reasons.


% The development of this implementation is free software and can be found at our version control system
% \url{http://escriny.epsem.upc.edu/svn/rrb//src/roundrobinson/tags/0.3/}.


\subsection{Pytsms}

Pytsms is the referent implementation for the model concepts of
measure, time series and temporal representation function.  Figure
\ref{fig:implementacio:pytsms-uml} shows the relationships among these
objects in a \acro{UML} diagram. A \emph{TimeSeries} object is an
aggregation of \emph{Measure} objects. \emph{TimeSeries} and
\emph{Representation} objects have a relation of association, that is
each \emph{TimeSeries} has a default representation and a
\emph{Representation} operates over a \emph{TimeSeries}.

%\tikzsetnextfilename{fig_pytsms_uml}
\begin{figure}[tp]
  \centering
  %\input{imatges/pytsms-uml.tex}
  \includegraphics{fig_pytsms_uml.pdf}
  \caption{Pytsms \acro{UML} class diagram}
  \label{fig:implementacio:pytsms-uml}
\end{figure}




A \emph{TimeSeries} object has a huge amount of methods, we classify
them based on their functionality. Firstly, a \emph{TimeSeries}
includes methods for manipulating the structural model, we implement
\emph{TimeSeries} as a subclass of the predefined \emph{Set} Python
type. Secondly, there are methods for set, sequence and temporal
function operators as described in Section~\ref{sec:model:operations}.
Thirdly, complementary operations for \emph{TimeSeries} are grouped
into two visitor objects: \emph{RegularProp} groups the regularity
operation definitions and \emph{Storage} has methods for storing and
retrieving time series from file system. Visitor is a pattern design
that allows new functionality to be added to objects without modifying
the objects
\cite{ziade08:expert_python_programming:visitor,martin02:visitor}.


Figure \ref{fig:implementacio:pytsms-uml} shows two specialisations
for \emph{Representation}. We show the two representations \emph{Zohe}
and \emph{Dd} in Section~\ref{sec:model:tfunc}. Basically, each
particular \emph{Representation} has the graph and the temporal
interval operation definition. Furthermore, there is also a method for
plotting coherently the time series to its representation; for which
we use the Python \emph{Matplotlib} library.



\begin{example}
  \label{ex:pytsms:example}
  We define in Pytsms the two time series $S1$ and $S2$ from
  Example~\ref{ex:model:s1s2} and we apply different operations:
  union, temporal union, concatenation, closed interval, \zohe{}
  temporal interval, \zohe{} temporal selection, and the test of
  regular property. Note that \emph{Measure} is abbreviated to
  \emph{m}.
\begin{lstlisting}[style=py]
#Importing the required objects
>>> from pytsms import TimeSeries, Measure as m
>>> from pytsms.representation import Zohe
>>> from pytsms.properties import isRegular

#Defining the two time series
>>> s1 = TimeSeries([m(1,1),m(3,1),m(4,0),m(5,1)])
>>> s2 = TimeSeries([m(2,2),m(3,2),m(4,0),m(6,2)])

#Manipulating the two time series
# Ã¦$s1 \cup s2$Ã¦
>>> s1.union(s2)
TimeSeries([m(1,1), m(2,2), m(3,1), m(4,0), m(5,1), m(6,2)])
# Ã¦$s1 \cupt s2$Ã¦
>>> s1.union_temporal(s2)
TimeSeries([m(1,1), m(2,2), m(4,0), m(5,1), m(6,2)])
# Ã¦$s1 || s2$Ã¦
>>> s1.concatenate(s2) 
TimeSeries([m(1,1), m(3,1), m(4,0), m(5,1), m(6,2)])
# Ã¦$s2[2,5]$Ã¦
>>> s2.interval_closed(2,5)
TimeSeries([m(2,2), m(3,2), m(4,0)])
# Ã¦$s2[2,5]^\zohe$Ã¦
>>> s2.interval_temporal(2,5,Zohe)
TimeSeries([m(3,2), m(4,0), m(5,2)])

#Checking the regularity
# Ã¦$s2$Ã¦ is not regular
>>> s2.accept(isRegular())
False
# Ã¦$s2$Ã¦ can be regularised by Ã¦$s2[{0,2,4}]^\zohe$Ã¦
>>> r2 = s2.selection_temporal(range(0,6,2),Zohe)
>>> r2
TimeSeries([m(0,2), m(2,2), m(4,0)])
>>> r2.accept(isRegular())
True
\end{lstlisting}
\end{example}





\subsection{RoundRobinson}


RoundRobinson is the referent implementation for the model concepts of
multiresolution time series, resolution subseries, buffers, discs, and
attribute aggregate functions. Figure
\ref{fig:implementacio:roundrobinson-uml} shows the relationships
among these objects in a \acro{UML} diagram. A
\emph{MultiresolutionSeries} object is an aggregation of
\emph{Resolution} objects. A \emph{Resolution} is composed of one
\emph{Buffer} and one \emph{Disc}. Each \emph{Buffer} is associated to
one \emph{TimeSeries}, from the Pytsms library, and each \emph{Disc}
is associated to another \emph{TimeSeries}, which respectively are
$S_B$ and $S_D$ of the \acro{MTSMS} model. Furthermore, each
\emph{Buffer} is associated to one attribute aggregate function which
is realised by defining a Python \emph{Function} with two parameters:
a \emph{TimeSeries} (\emph{s}) and a consolidation time interval
(\emph{i}).



%\tikzsetnextfilename{fig_roundrobinson_uml}
\begin{figure}[tp]
  \centering
  %\input{imatges/roundrobinson-uml.tex}
  \includegraphics{fig_roundrobinson_uml.pdf}
  \caption{RoundRobinson \acro{UML} class diagram}
  \label{fig:implementacio:roundrobinson-uml}
\end{figure}



A \emph{MultiresolutionSeries} is a subclass of the predefined \emph{Set} Python
type. It has complementary operations that are grouped into two
objects: \emph{Storage} has methods for storing and retrieving
multiresolution time series from file system and \emph{Plot} has
methods for plotting the time subseries of the multiresolution schema.


A \emph{MultiresolutionSeries} has a method \emph{addResolution} for defining
the multiresolution schema structure by adding resolution
subseries. Every new resolution is configured by four parameters:
\emph{delta}, \emph{k}, \emph{f}, and \emph{tau} that create the
corresponding buffer and disc.  A \emph{MultiresolutionSeries} has methods
\emph{add}, \emph{consolidable}, and \emph{consolidate} that operate on
the corresponding methods of the contained resolution subseries.


A \emph{MultiresolutionSeries} can be queried by two methods:
\emph{seriedisc} and \emph{totalseries}. The \emph{seriedisc} returns
the \emph{TimeSeries} for the selected disc by parameters \emph{delta}
and \emph{f}. The \emph{totalseries} returns the \emph{TimeSeries}
that results from the concatenation of all \emph{seriedisc} ordered by
\emph{delta}.
% as there can not be repeated \emph{delta}, \emph{totalseries} has a
% parameter \emph{f} for selecting only \emph{discSeries} with a
% determined attribute aggregate function.

In a module \emph{aggregators} we have implemented some default
attribute aggregate functions, although users can define more as they
are Python \emph{Function} objects with parameters \emph{s} as a
\emph{TimeSeries} and \emph{i} as a pair of times like
\emph{[t0,tf]}. As instance we have defined the \zohe{} aggregate
functions from Section~\ref{sec:model:interpolador}, which basically
aggregate over the temporal interval
\lstinline[style=py]+s.interval_temporal(t0,tf,Zohe)+ shown in
Example~\ref{ex:pytsms:example}.


\begin{example}
  We define in Pytsms the time series $S$ and in RoundRobinson we
  define the multiresolution time series $M_\emptyset$ from
  Example~\ref{ex:model:smultiresolution}, we apply consolidation and
  we query the result.

\begin{lstlisting}[style=py]
#Importing the required objects
>>> from pytsms import TimeSeries, Measure as m
>>> from roundrobinson import MultiresolutionSeries
>>> from roundrobinson.aggregators import mean_zohe,maximum_zohe

#Defining the original time series
>>> s = TimeSeries([m(1,6),m(5,2),m(8,5),m(10,0),m(14,1),m(19,6),m(22,11),m(26,6),m(29,0)])

#Defining the multiresolution time series
>>> M = MultiresolutionSeries()
#Defining the multiresolution schema
>>> M.addResolution(delta=5,k=4,f=mean_zohe,tau=0)
>>> M.addResolution(delta=10,k=2,f=maximum_zohe,tau=0)

#Adding the measures
>>> for m in s: M.add(m)
#M is consolidable
>>> M.consolidable()
True
#Consolidating until no more consolidable
>>> while M.consolidable():
...    M.consolidate()

#Query Ã¦$\seriedisc(M,5,\text{mean}^\zohe)$Ã¦
>>> M.seriedisc(5,mean_zohe)
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
#Query Ã¦$\seriedisc(M,10,\text{maximum}^\zohe)$Ã¦
>>> M.seriedisc(10,maximum_zohe)
TimeSeries([m(10,6), m(20,11)])
#Query Ã¦$\totalseries(M)$Ã¦
>>> M.totalseries()
TimeSeries([m(10,3), m(15,2), m(20,7), m(25,8)])
\end{lstlisting}
\end{example}






%\input{example}
\section{Example}
\label{sec:example}


Next we show a real example database for a time series data. Actual
data comes from a temperature distributed sensor monitoring system
\cite{alippi10}, we focus on one sensor data. We use Pytsms and
RoundRobinson implementations in order to create a \acro{MTSDB} and
to query it.

\emph{Data}. The Figure~\ref{fig:exemple:original} shows the original
data for one year and a half. The plot interpolates linearly the
measures. In this plot we can see that there is missing data and some
outlying observations. There are $146\,709$ stored values.

\begin{figure}[tp]
  \centering
  %\tikzset{every picture/.style={scale=0.8}}
  %\tikzsetnextfilename{fig_exemple_original}
  %\input{imatges/isense_original.tex}
  \includegraphics{fig_exemple_original.pdf}
  \caption{Example of a temperature time series data}
  \label{fig:exemple:original}
\end{figure}

\emph{Schema}. We design a \acro{MTSDB} that stores a multiresolution
time series with high resolution at recent times and with low
resolution at older times. The schema is illustrated in the
Figure~\ref{fig:exemple:window}. At the top there are four discs with
different number of measures and at the bottom there is a timeline
showing the resolution subseries along time. Going from most to least
granularity, disks are configured as follows: (i) a measure every 5 h
in the fourth disc which has a capacity of 24 measures and thus it
spans 5 days; (ii) a measure every 2 days in the third disc, with a
capacity of 20 thus spanning 40 days; (iii) a measure every 15 days in
the second disc, with a capacity of 12 thus spanning 180 days and;
(iv) a measure every 50 days in the first disc that, with a capacity
of 12 results in a span of 600 days.

\begin{figure}[tp]
  \centering
  \setlength{\unitlength}{1.3mm}
  %\input{imatges/mtsdb-time_window.tex}
  \includegraphics{fig_exemple_window.pdf}
  \caption{Schema of multiresolution}
  \label{fig:exemple:window}
\end{figure}

\emph{Attribute aggregate functions}.  In order to illustrate this
example we consolidate all the resolution subseries using the
mean$^\zohe{}$ aggregate function and the two highest resolution
subseries using the maximum$^\zohe{}$ aggregate function. 



\emph{Consolidation}. The time subseries after consolidating the
\acro{MTSDB} are shown in the Figure~\ref{fig:exemple:4mrd}, where
each graphic corresponds to the possible $\seriedisc$ queries, that is
every resolution disc time series from the \acro{MTSDB}. Each title
shows the resolution subseries and its cardinal, and each attribute
aggregate function has different colour.  Each time series is plotted
with \zohe{} representation function $S(t)^\zohe{}$. Time axis has
\acro{UTC} units rounded to nearest time points and temperature axis
has Kelvin units. Outlayers are marked as discontinuities, for
instance see fourth plot's 2938 K maximum.

\begin{figure}[tp]
  \centering
  % \tikzset{
  %   every picture/.style={scale=0.7},
  % }
  % \input{imatges/isense_4mrdb.tex}
  \includegraphics{fig_exemple_4mrd1.pdf}
  \includegraphics{fig_exemple_4mrd2.pdf}
  \includegraphics{fig_exemple_4mrd3.pdf}
  \includegraphics{fig_exemple_4mrd4.pdf}
  \caption{Resolution subseries in the MTSDB}
  \label{fig:exemple:4mrd}
\end{figure}

In all the four plots, we can see that mean aggregate function has
filled missing data and filtered outlayer observations. This is due
to the aggregate function coming from a \zohe{} interpretation.

Figure~\ref{fig:exemple:4mrdtot} shows the $\totalseries$
queries for the mean$^{\zohe}$ aggregate function resolution and for
the maximum$^{\zohe}$ resolution.  Each resulting time series is
plotted interpolating linearly its measures, note that this linearly
visualisation seems right time displaced as time series comes from a
\zohe{} aggregation.  Comparing this figure with the original series
in Figure~\ref{fig:exemple:original}, we observe that it resembles an
incremental low-pass filter because we applied mean aggregation while
the maximum aggregation resembles an envelope function.

%\tikzsetnextfilename{fig_exemple_4mrdtot}
\begin{figure}[tp]
  \centering
  %\tikzset{every picture/.style={scale=0.8}}
  %\input{imatges/isense_mrdb-all.tex}
  \includegraphics{fig_exemple_4mrdtot.pdf}
  \caption{$\totalseries$ for the mean$^{\zohe}$ and maximum$^{\zohe}$
    resolutions}
  \label{fig:exemple:4mrdtot}
\end{figure}


In conclusion, this \acro{MTSDB} example schema does not store the
complete original data but a compression of the original function
which contains more information for recent times.  Each of the
$\seriedisc$ time series is regular with $\delta$. Although
$\totalseries$ is not a regular time series, it has piece-wise
regularity as a concatenation of every disc's $\delta$.  The purpose
of this example is to show how the multiresolution is computed for a
time series, it has been computed offline as the original data had
already been acquired. However, a \acro{MTSMS} is designed to
consolidate while the original data is being acquired so that the
multiresolution computation spreads along the acquisition and the
computing time becomes less critical.




%\input{conclusions}



\section{Conclusions}
\label{sec:concl-future-work}


In this paper we have shown a \acro{MTSMS} model, including a
motivation example for multiresolution and an application together
with \acro{TSMS}. Our \acro{MTSMS} model is based on \acro{TSMS}
notation which we have described firmly rooted on set and relational
algebra. We have gone a bit further and proposed \acro{TSMS} including
set, sequence and temporal function behaviour.



The main objective of a \acro{MTSMS} is to store compactly a time
series and manage consistently its temporal dimension.  It stores
multiresolution time series, that is time series split into time
subseries called resolution subseries.  Each resolution subseries has
a different resolution and is compacted with an attribute aggregate
function. Therefore, each multiresolution time series is configured by
the quantity of resolution subseries and four parameters for each: the
consolidation step, the initial consolidation time, the attribute
aggregate function, and the capacity.  These configuration parameters
are degrees of freedom for each application. Giving different values a
multiresolution database is capable to keep the desired information
from a time series. %
We have showed some aggregation functions examples with simple
aggregation statistics, mean and maximum, and simple representation
methods, Delta and \zohe{}. More attribute aggregation functions could
be designed based on methods from other fields such as data streaming
or time series data mining, especially it would be interesting aggregations with uncertain data.


The queries over \acro{MTSMS} obtain time series from stored
multiresolution time series. In this way \acro{TSMS} operators can be
applied if needed. The $\seriedisc$ time series being regular
facilitates these operations. However, the lossy storage implies that
some operations will give approximate queries and that not every
\acro{TSMS} operation will be semantically correct for a
multiresolution time series. Therefore the correct planning of the
multiresolution schema is needed.


Compared to other \acro{TSMS} we propose a compression solution that
stores only the information we will require by latter queries or by
human visualisation, instead of trying to reconstruct the original
signal.  Moreover, our multiresolution solution copes well with
typical problematic properties of time series: regularity, data
validation and data volume.  The decompression time is minimal as data
in discs get stored directly as a time series. As a consequence, the
queries or visualisation computing time is only due to the computation
itself. Moreover, if the query is an aggregation or resolution already
computed in \acro{MTSMS} consolidation, then the visualisation is
immediate.


\acro{MTSMS} imply a data information selection and so the information
not considered important is discarded. 
% When this is not possible, we
% have showed a dual structure of \acro{TSMS} and \acro{MTSMS}. Then a
% \acro{TSMS} stores losslessly and a \acro{MTSMS} takes advantages of
% manipulating data in time order in order to achieve pre-computed
% queries in a stream-like orientation. 
In future work, information
theory has to be evaluated for multiresolution schemes. As multimedia
lossy compression techniques are well founded on information theory,
similar approaches could be taken for multiresolution time series,
e.g. evaluating whether a human can visualise original qualities in
the multiresoluted time series or evaluating
whether given a query it has the same validity for a multiresoluted
one as it has for the original.




A \acro{MTSMS} could be implemented as a SQL \acro{DBMS} system or as
a NoSQL one. As a referent implementation we have developed a
\emph{Python} package centred on the basic algebra, that is without
extended \acro{DBMS} capabilities. Regarding other implementations,
\emph{RRDtool} can be seen as an specific case of \acro{MTSMS} and as
a NoSQL system, although Oetiker \cite{rrdtool} has not commented
it. However, regardless of the implementation backend, we have shown
how a generic model for \acro{MTSMS} can be defined firmly rooted on
\acro{DBMS} algebra theory.





\section*{Acknowledgements}

The research presented in this paper has been supported by Spanish
research projects \textsc{tec2012-35571} and \textsc{dpi2011-26243},
the UE project i-Sense (\textsc{fp7-ict-270428}), and Universitat
Polit\`{e}cnica de Catalunya predoctoral grant.



%\section*{References}
\bibliography{bibelsarticle}


\appendix
%\input{notation}
\section{Notation}
\label{sec:notation}
{\small

Name and symbol notation. Divided into \acro{TSMS} and \acro{MTSMS}
notation and each organised into its components.



\begin{supertabular}{ll}


\textbf{TSMS} & \\\hline


\textbf{Time} & $t\in T$\\
Duration & \ensuremath{t^d}\\
Reference time & \ensuremath{t^R}\\
Time domain & \ensuremath{T} (e.g.~$\bar{\mathbb{R}}$) \\
Time instant & \ensuremath{t^i}\\

\textbf{Value} & \ensuremath{v\in V}\\
Value domain & \ensuremath{V} (e.g.~$\mathbb{R}*$) \\

\textbf{Measure} & \ensuremath{m=(t,v)}\\
Time & \ensuremath{T(m)}\\
Value & \ensuremath{V(m)}\\


\textbf{Time series} & \ensuremath{S=\{m_0,\dotsc,m_k\}}\\
Multivalued & \ensuremath{m=(t, v_1,\dotsc, v_n)}\\
Cardinality & $|S|$\\
Regularity & $S$ is regular\\

\textbf{Set operations} & \\
Difference & \ensuremath{S_1 - S_2}\\
Infimum & \ensuremath{\inf(S)}\\
Intersection & \ensuremath{S_1\cap S_2}\\
Join & \ensuremath{S_1 \operatorname{join} S_2}\\
Maximum & \ensuremath{\max(S)}\\
Membership & \ensuremath{m\in S}\\
Minimum & \ensuremath{\min(S)}\\
Supremum & \ensuremath{\sup(S)}\\
Symmetric difference & \ensuremath{S_1\ominus S_2}\\
Temporal membership & \ensuremath{m\in^t S}\\
Temporal union & \ensuremath{S_1\cup^t S_2}\\
Union & \ensuremath{S_1\cup S_2}\\

\textbf{Computational operations} & \\
Aggregate & \ensuremath{\operatorname{aggregate}(S,m_i,f^a)}\\
Aggregate function & \ensuremath{f^a: m_a\times m_b \mapsto m_r}\\
Fold & \ensuremath{\operatorname{fold}(S,S_i,f^f)}\\
Fold function & \ensuremath{f^f: S_a\times m_b \mapsto S_r}\\
Fold order function & \ensuremath{o: S_a \mapsto m_r}\\
Fold with order & \ensuremath{\operatorname{ofold}(S,S_i,f^f,o)}\\
Map & \ensuremath{\operatorname{map}(S,f^m)}\\
Map function & \ensuremath{f^m:m_a\mapsto m_r}\\

\textbf{Sequence operations} & \\
Concatenation & $S_1 || S_2$ \\
Interval & \ensuremath{S(t^i_a,t^i_b), S[t^i_a,t^i_b],\ldots }\\
Predecessor & \ensuremath{\operatorname{prev}_S(m)}\\
Successor & \ensuremath{\operatorname{next}_S(m)}\\

\textbf{T. function operations} & \\
Dirac delta & $r=\dd{}$\\
Representation function & $S(t)^r$\\
Representation method & $r$\\
Temporal interval & \ensuremath{S[t^i_a,t^i_b]^r}\\
Temporal selection & \ensuremath{S[\{t_0,\dotsc,t_n\}]^r}\\
Zero-order hold everted & $r=\zohe{}$\\

\\

\textbf{MTSMS} & \\\hline



\textbf{Buffer} & \ensuremath{B=(S_B,\tau,\delta,f)}\\
Add measure & $\operatorname{addB}(B,m)$\\
Attribute aggregate function & $f$\\
Buffer time series & $S_B$\\
Consolidable & $B$ is consolidable\\
Consolidate  buffer & $\operatorname{consB}(B)$\\
Consolidation duration & $\delta$\\
Last consolidation time & $\tau$\\

\textbf{Disc} & \ensuremath{D=(S_D,k)}\\
Add measure & $\operatorname{addD}(D,m)$\\
Disc time series & $S_D$\\
Maximum cardinality & $k$\\

\textbf{Resolution subseries} & \ensuremath{R=(B,D)}\\
Add measure & $\operatorname{addR}(R,m)$\\
Consolidable & $R$ is consolidable\\
Consolidate & $\operatorname{consR}(R)$\\

\textbf{Multiresolution time series} & \ensuremath{M=\{R_0,\dotsc,R_d\}}\\
Add measure & $\operatorname{addM}(M,m)$\\
Consolidate & $\operatorname{consM}(M)$\\

\textbf{Queries} & \\
Disc selection & $\operatorname{SerieDisc}(M,\delta,f)$\\
Total time series & $\operatorname{TotalSeries}(M)$\\

\end{supertabular}
}



\end{document}





%%% Local Variables: 
%%% ispell-local-dictionary: "british"
%%% End: 