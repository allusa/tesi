\chapter{Discussions/Usos/Aplicacions de SGSTM}



\section{Multiresolution over TSMS}


* MTSMS expressada com una consulta  sobre TSMS

Potser expressar com dues coses: una selecció de l'interval + una agregació sobre aquesta subsèrie temporal?

  \begin{align*}
    S_D \equiv &  \operatorname{map}(S_I, m_i\mapsto m') \text{ on }  \\
    & m' = (T(m_i), f(S, i)), i = [T(\operatorname{prev}_{S_I}(m_i)),T(m_i)] \\
    &  S_I = \{ (t,\infty) | t\in T_I  \}, T_I = \{ t_i = \tau+n\delta | n\in\N, t_M - k\delta < t_i \leq t_M \}, t_M = T(\max(S))
  \end{align*}
  
En aquest cas hem suposat que la $f$ segueix sent un agregador d'atributs $f:S\times i\rightarrow m$. Però podríem simplificar dient que és un agregador que segueix la forma ja coneguda dels TSMS $f_a \equiv agg:S\times m_i \times f \rightarrow m'$ on $f:m_i\times m\rightarrow m''$ i aleshores ho podem veure dos mapes:
  \begin{align*}
    S_D \equiv &  \operatorname{map}(S', m_i\mapsto m') \text{ on }  \\
    & m' = (T(m_i), f_a(V(m_i)))
    & S' = \operatorname{map}(S_I, m_i\mapsto m'') \\
    & m'' = (T(m_i), S[t_a,t_b]), t_a = T(\operatorname{prev}_{S_I}(m_i)), t_b=T(m_i) \\
    &  S_I = \{ (t,\infty) | t\in T_I  \}, T_I = \{ t_i = \tau+n\delta | n\in\N, t_M - k\delta < t_i \leq t_M \}, t_M = T(\max(S))
  \end{align*}
de manera que la feina de treure les subsèries la fa el mapa sobre $S_i$ mentre que abans la feia cada funció d'agregació d'atributs. Per a poder extreure aquesta part de selecció de l'interval dels $f$ cal interpretar-los, no es pot fer de manera automàtica.



* Si una consulta multiresolució(S) és una combinació de map i fold es podria fer en SGBD de tipus MapReduce?


\section{Estructures interessants}



\subsection{Discos enllaçats}


Aquesta pot ser útil per al filó distribuït. 

* Si quan s'entra una mesura aquesta ha d'anar a totes les subsèries resolució, aleshores el filó distribuït no té sentit perquè igualment han d'arribar les mesures noves al node central.

* Però si hi ha discos enllaçats aleshores només cal anar transferint la subsèrie consolidada cap amunt i llavors un cop es llança una consulta aquesta decideix si té prou resolució al node on és o ha d'anar a buscar-ne d'un altre. Aquesta decissió de la consulta pot fer-se a mà, consultes amb SerieDisc()  indiquen quin disc s'ha d'anar a buscar, per tant l'usuari tria quin vol i sap si s'haurà d'anar a buscar a fora. 


\paragraph{Exemple 2}

Les taules es poden veure a la \autoref{fig:model:mtsdb:cadena} a on la base de dades multiresolució és la vista-relació 
\begin{verbatim}
M_2 = ( ((M_2' RENAME S'_B AS S') JOIN (M^{series}_2 RENAME S AS S_B)) RENAME S'_D AS S') JOIN (M^{series}_2 RENAME S AS S_D)
\end{verbatim}



\begin{figure}[tp]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \multicolumn{2}{c}{$M'_2$} \\ \hline
    $S'_B$  & $S'_D$ & $\tau$ & $\delta$ & $k$ & $f$ \\ \hline
    $S_{B1}$ & $S_{D1}$ & 45 & 5  & 2 & mitjana  \\
    $S_{D1}$ & $S_{D2}$ & 40 & 10 & 4 & mitjana  \\ \hline
  \end{tabular}\qquad
  \begin{tabular}{|c|c|c|}
    \multicolumn{3}{c}{$M^{series}_{2}$} \\ \hline
    \multirow{2}{*}{$S'$}  &  \multicolumn{2}{c|}{$S$} \\ \cline{2-3}
    & $t$      & $v$  \\ \hline
    \multirow{3}{*}{$S_{B1}$} & 46 & 0 \\ 
    & 48 & 0 \\ 
    & 49 & 0 \\ \hline
    \multirow{2}{*}{$S_{D1}$} & 40 & 0 \\ 
    & 45 & 0 \\ \hline
    \multirow{4}{*}{$S_{D2}$} & 10 & 0 \\ 
    & 20 & 0 \\ 
    & 30 & 0 \\ 
    & 40 & 0 \\ \hline
  \end{tabular}
  \caption{Taula d'una mtsdb en cadena}
  \label{fig:model:mtsdb:cadena}
\end{figure}

\todo{per a fer l'exemple falta conèixer els operadors estructurals}

\todo{falta definir qui són els buffer d'entrada de mesures}
definir una $M^{in}_2$.





Respecte a l'estructura general, l'estructura enllaçada restringeix
els períodes de consolidació de les sèries temporals: aquests són
múltiples dels discs anteriors.



\subsection{Data stream}



Base de dades multiresolució a on les sèries temporals dels buffers
només tenen una mesura; és a dir tenen cardinal afitat a 1.


Per a orientar a streams els buffers s'han de canviar els operadors
d'afegir i consolidar:

Es canvia l'operador d'afegir per tal que incorpori el càlcul orientat
a stream cada cop:
\[
\text{addB}^{\text{stream}}: B \times m \longrightarrow B' =
(streamB(S,m),\tau,\delta,f)
\]

Es canvia l'operador de consolidar per tal que reconegui la sèrie
temporal del buffer com a consolidada amb stream.

  \[
  \text{consolidaB}^{\text{stream}}: B \longrightarrow B' \times m'
  \]
  \[
  B'= (S',\tau+\delta,\delta,f)
  \]
  \[
  S' = S(\tau+\delta,\infty)
  \]
  \[
  m' \in S(\tau,\tau+\delta] 
  \]


Per a orientar a streams els buffers es defineix un nou operador
\[
\text{streamB}: S \times m \longrightarrow S' = \{f^{\text{stream}}(m_o,m)\}
\]
\[
m_o \in S
\]
\[
f^{\text{stream}} \text{ és un agregador d'atributs orientat a streams}
\]
 

Aleshores els agregadors d'atributs funcionen orientats a stream;
nota: no tots els agregadors d'atributs es poden definir com a
streams.


Per exemple l'interpolador mitjana orientat a stream:

\[
\text{mitjana}^{\text{stream}}: m_o \times m_n \longrightarrow m' = (T(m_n),v')
\]
\[
\text{a on } v' = (V(m_0) + V^1(m_n), V^2(m_n) + 1 )
\]






\subsection{Compartició de buffers}


Les diferents $f$ amb mateix $\delta$ poden compartir buffer.


Tenir un buffer únic per a totes les subsèries i que no s'esborrin mesures.




\subsection{Lapses de buffer o no lapses}

Podem tenir esquemes de multiresolució a on les diferents subsèries
resolució coincideixin en els temps recents o a on no coincideixin:
les subsèries més velles acabin on comencen les noves de manera
semblant a l'estructura de buffers enllaçats.

La primera opció pot servir per quan hi ha moltes dades tenir diferents resums preparats per a ser visualitzats, així permet triar ràpidament entre diferents zooms de les dades.

La segona opció serveix per aprofitar al màxim la resolució i l'espai d'emmagatzematge, sense que cap subsèrie desi informació per al mateix interval de temps. Així permet conservar una sèrie temporal al llarg del seu temps amb diferents resolucions. També pot servir per usar la informació d'altres buffers i no haver de repetir emmagatzematge de buffers.


\subsection{Incerteses en el temps}


El temps pot ser vist com un valor amb incertesa. Aleshores què passa amb les operacions?





\subsection{Vistes pre-calculades i vistes actualitzades en flux}

Nathan Marz ``A call for sanity in NoSQL''

Lambda Architecture: batch view vs. real time view

Els SGBDM podrien ser utilitzats en les real time view



Sembla que en el món SQL les vistes pre-calculades s'anomenen
\emph{materialized views}. Date %\cite{date13}
 proposa que s'anomenin
\emph{snapshots}. Es podrien definir com unes taules amb caching de les dades.

PostgreSQL no té materialized views però aquí expliquen com definir-ne a partir de triggers. \url{http://tech.jonathangardner.net/wiki/PostgreSQL/Materialized_Views}.


En els SGBDR les views funcionen com a la teoria relacional, és a dir
com a àlies d'una consulta, i per tant cada cop que s'utilitzen es
calculen. Això fa que siguin lentes quan hi ha moltes dades. Tot i
així, estranyament, el caching de views no és un tema molt treballat
en els SGBDR. Sembla que els SGBDR per millor l'eficiència haurien de
permetre fer caching de les vistes i actualitzar-les segons diversos
patrons:
\begin{itemize}
\item Periòdicament, p.ex. cada 5 minuts
\item Esdeveniments en base a triggers de les relvars de les quals
  depèn la vista, p.ex. s'actualitza quan es modifica la relvar
  original
\item En flux en base a triggers de les relvars de les quals depèn la
  vista, p.ex. s'actualitza quan es modifica la relvar original i es
  diu quina acció s'ha de fer per modificar la vista. Aquest cas és
  molt més complicat que els altres dos i requereix especificar la
  instrucció d'actualització. Un exemple seria un SGSTM com a caching
  de consultes multriesolution(S) llançades a un SGST.
\end{itemize}



\subsection{Arquitectura RRDtool}


RRDtool té una estructura multiresolució amb un buffer únic d'entrada
i buffers orientats a stream; segons havíem avaluat anteriorment \parencite{llusa11:tfm}.


S'ha d'estudiar com es fan les consultes a RRDtool

\url{http://en.wikipedia.org/wiki/RRD_Editor}



Podem considerar que:

1. RRDtool és un SGBD NoSQL?
2. Nosaltres n'hem formalitzat un model lògic?
3. És el primer model lògic per a un producte NoSQL?
4. Aquest model lògic es pot implementar tant en productes relacionals com amb NoSQL? i per tant es demostra que els models lògics són extremadament potents i necessaris?
5. La implementació que fa RRDtool és molt eficient per a un determinat camp d'aplicació?
6. La implementació relacional seria molt genèrica i propera al model però no tan eficient? més aviat subjecte a l'eficiència genèrica dels SGBDR?
7. Els SGST són uns SGBD més simples? no tenen tantes actualitzacions de valors, no hi ha tantes relationships en l'esquema... Els SGST només es preocupen de sèries temporals i per tant només d'un tipus de dades en concret, això no obstant tal com s'ha dissenyat el model aquest tipus de dades es pot implementar en SGBD més complexos. 

\subsection{Arquitectura Pandas}

\todo{}
Si parlem de RRDtool també hem de palar de Pandas?




\subsection{Push i pull}

Estudiar Push o pull aplicada als SGSTM i quines implicacions pot tenir.


\subsection{Rellotge}

Parlar de com ha de ser el rellotge en un SGSTM. Pot ser:

* intern (pull): el SGSTM té un rellotge que li va marcant cada quan consolidar; per tant és ell que va decidint quines mesures s'agafaven i quines no i com. En diem de tipus pull perquè d'alguna forma és el SGSTM qui tiba les mesures; en aquest cas fins i tot es podrien contemplar escenaris a on el SGSTM reclamés mesures quan li semblés que no disposa de prou informació.

* extern (push): el SGSTM no té rellotge sinó que les mesures que entren ja tenen un temps i s'assumeix que entren ordenades en el temps; aleshores d'aquesta entrada de mesures s'extreu el rellotge; és a dir que es van sabent els instants de consolidació a partir de les mesures. Això pot provocar un cert decalatge del temps del SGSTM amb el del rellotge real; ja que el primer només canvia quan té mesures noves. En diem de tipus push perquè les mesures són les que controlen el procés (bé el sistema de monitoratge extern). 

* discret: tipus la cpu marca el rellotge; en aquest cas no hi ha un rellotge real sinó que es compten esdeveniments i el rellotge es crea relativament a aquest comptatge. Per exemple és el cas de sistemes encapsulats a on no hi ha RTC i el clock diu cada quan s'ha de consolidar (en aquest moment es consoliden les mesures de què es disposi, les quals potser tampoc tenen temps i per tant el rellotge del SGSTM serà relatiu) o bé un altre exemple és quan la consolidació d'una subsèrie resolució depèn d'una altra subsèrie (p.ex. es consolida cada cop que l'altre ha expulsat quatre mesures).




\todo{}
* orientat a esdeveniments (event triggered)
* amb rellotge (time triggered)

* en cas de comptadors digitals, aquests cada cop que incrementen el valor poden fer un push a la base de dades. En comptadors analògics no ho poden fer perquè van incrementant contínuament i no discretament.

\subsection{Què fer sense coneixements a priori}

Una base de dades multiresolució requereix tenir un coneixement de l'entorn a priori per a poder establir-ne l'esquema de multiresolució. Perquè un cop establit aquest esquema només s'emmagatzemen els atributs seleccionats i es perd informació sobre la sèrie temporal original.

Per això si la informació és crítica una bona estructura de base de dades consistiria en un magatzem total de la informació recollida i un magatzem multiresolució amb un esquema inicial. La base de dades multiresolució s'utilitzaria per a les consultes habituals que s'haguessin de resoldre de forma ràpida, en cas que les respostes no fossin suficients es podria anar a buscar la informació al magatzem total, a on la resolució de la consulta tindria un temps més elevat. 
Aleshores si aquestes consultes esdevinguessin habituals es podria definir un nou esquema de multiresolució i iniciar-lo amb les dades del magatzem total (això tardaria un cert temps) per a després executar-hi les consultes de forma ràpida.


Tot i així cal notar que en moltes aplicacions les dades històriques
són prescindibles i es pot canviar l'esquema de multiresolució sense
gaires preocupacions. Per exemple un sistema de monitoratge de la
bateria que tenim disponible al portàtil.

També en altres aplicacions el que volem es resoldre una consulta del tipus la mitjana puja o baixa. En això el model de multiresolució hi encaixa molt bé ja que es base en calcular agregacions i després treballar sobre aquestes. 









\section{Operacions habituals en les sèries temporals}


\paragraph{Semblança de dues sèries temporals}


Similarity Measures for Time Series

Hi ha varis mètodes, [keogh08:vldb] n'avalua uns quants i els generalitza amb:

Given two
time series T1 and T2 , a similarity function Dist calcu-
lates the distance between the two time series, denoted by
Dist(T1 , T2 ).

Exemplifiquem amb la distància euclídia, [keogh08:vldb] nota que és
competitiva amb les altres.

Distancia euclídia segons [faloutsous94-sigmod]


\[
D(S,Q) = \left( \sum_{i=1}^{l} (S[i]-Q[i])^2  \right)^{1/2}
\]

\begin{gather*}
  D: S \times Q \longrightarrow v: \\
  S' = map(fusio(S,Q),(t,v_1,v_2)\mapsto(t,(v_1-v_2)^2)), \\
  S'' = fold(quad,(0,0),(t^1,v^1,t^2,v^2)\mapsto(t^1,v^1+v^2)), \\
  v = \sqrt{V(m)}:m\in S''
\end{gather*}


S i Q haurien de ser regulars entre elles, sinó cal aplicar una fusió amb representació/interpretació.

Amb la multiresolució la fusió es pot fer de forma eficient. Per altra banda, es podria crear un disc resolució amb agregador de semblança.


\paragraph{Semblança de dues sèries temporals amb offset}

Aquí es descriu la solució general del problema (SequentialScan),
[faloutsous94-sigmod] n'estudia implementacions amb certes
heurístiques que aconsegueixen més eficiència.





\paragraph{Filtratge senzill per mitjana mòbil}

Sigui $p$ la mida de la finestra mòbil
\begin{gather*}
  \text{MitMobil}: S \times \text{p} \longrightarrow S':\\
  \text{map}(S,(t,v)\mapsto \text{mitjanaV}(S[t,t+p]))
\end{gather*}


Mitjana mòbil sobre la multiresolució



\paragraph{Farciment de forats}

Jo tinc una sèrie temporal i vull que entre dues mesures no hi hagi més d'un cert temps. Si no es compleix dic que té forats. 

Sigui $S$ una sèrie temporal, aquesta té forats de més durada que $d$
si alguna mesura compleix $\text{forats}(S,d) = \text{selecciona}(difT(S),v>d \bigwedge v\neq\infty)$ a on $difT(S) = \text{map}(\text{tpredecessors}(S),(t,v)\mapsto(t,t-v))$.

Amb la multiresolució el farciment de forats és natural a l'estructura i és controlat per la funció agregadora d'atributs.


* Com farciria els forats manualment a una sèrie temporal?

1. Passar-ho per un esquema de multiresolució

2. Treballar sobre la sèrie temporal:

a partir del càlcul de forats anterior $\text{forats}(S,d)$ per
exemple apliquem un farciment amb representació
zohe. $\text{farciment}(S,d) = \text{unio}(S,S')$ a on fem la selecció
de resolució $S' = S[T]^{\text{zohe}}$, $\forall (t,v) \in
\text{forats}(S,d): T = \{ \tau = t - dn |
\tau\in(t-v,t),n\in\mathbb{N} \}$.







\subsection{Com treure profit de les operacions dels SGSTM}

Temes que després es poden aprofitar a les implementacions

* No hi ha updates --> les sèries temporals no s'han de canviar

* Per exemple, vull calcular la mitjana de  BDSTM(a,b] si tinc un disc resolució amb $\delta=b-a$ i $f=$mitjana aquest seria l'adequat en comptes de calcular mitjana(SerieTotal(M)(a,b])

%??
% No obstant, la base de dades multiresolució conté informació sobre la
% resolució de les subsèries i per tant aquesta operació és susceptible
% d'implementar-se aprofitant aquesta informació.  A tall d'exemple es
% defineix una operació per extreure de la base de dades multiresolució
% una sèrie temporal regular amb període $T$:


% \begin{definition}[Selecció de resolució regular]
%   \begin{gather*}
%     \text{ResolucióRegular}: M^* \times T \times r \longrightarrow S'\\
%     \forall (S_{Bi},S_{Di},\delta_i,\tau_i,k_i,f_i) \in M : \\
%     d_i = T - \delta_i , \\
%     0 \geq d_0 > d_1 \dots > d_a, 0 < d_{a+1} < \dots < d_d: \\
%     S'' = S_{D0} || S_{D1} || \dotsb || S_{Da}  ||  S_{Da+1} || \dotsb || S_{Dd}, \\
%     S' = S''[i]^r: i = {t|0+nT,n\in\mathbb{N}}
%   \end{gather*}
% \end{definition}

% Nota: les operacions no són equivalents, l'operació $\text{SerieTotal}(M)[i]^r$ és molt més potent que la $\text{ResolucióRegular}(M,T)$.




\subsection{Comparació d'operacions dels SGSTM amb les dels SGST}

Tinc una sèries temporal $S$ i l'emmagatzemo a una base de dades multiresolució $M$ amb atributs de mitjana. 

* mitjana(S) = mitjana(serieTotal(M)) ?

* Operació O, afegeix(M',O(S)) = O(serieTotal(M))?


\begin{align*}
s   \qquad   &  s'=ST(M(s))\\
r=O(s) \qquad& r'=O(s') \\
\epsilon(r,r')?
\end{align*}

on $O$ és una consulta, per exemple pot ser O=Creix la sèrie temporal? Si la resposta és Sí en els dos casos, aleshores no hi ha error.



\subsection{Rapidesa/eficiència dels SGSTM}

Aquí només hem definit el nivell lògic i les implementacions que volem
fer només són per exemplificar el model lògic; és a dir que les farem
tan properes al model lògic com es pugui. La rapidesa/eficiència dels
SGSTM només la podríem avaluar a les implementacions; a on es podrien
aplicar models d'implementacions que se saben eficients. Com que no és
el cas, no té sentit avaluar ni comparar l'eficiència de les nostres
implementacions amb altres de semblants.







\section{Comparació de SGST i SGSTM amb altres models del mercat}


SGST:

* Respecte dels models de seqüència: 

  - una seqüència es defineix com una funció el domini de la qual és un conjunt comptable i totalment ordenat. La definició genèrica que fem del temps no és un conjunt comptable i per tant creiem que un model genèric de sèries temporals no es pot descriure amb comoditat des de les seqüències. 

  - generalment s'assumeix que la distància entre els elements d'una seqüència és regular

  - els instants de temps en una sèrie temporal no es poden canviar, en canvi en una seqüencia els índexs només marquen l'ordre i no significat de posicionament en un marc de referència.






\section{Resum}

Aquest capítol s'acaba amb un resum dels conceptes exposats en el
model de dades. Una base de dades per sèries temporals multiresolució
és un sistema informàtic d'emmagatzematge d'una sèrie temporal entesa
com una una co\l.lecció de dades mesurades en diferents instants de
temps.

A la base de dades, la sèrie temporal queda estructurada com s'ha esquematitzat a  la figura~\ref{fig:model:bdstm}. És una forma compacta d'emmagatzemar la sèrie temporal de manera que queda repartida segons diferents funcions d'interpolació i períodes de mostreig. Aquest repartiment té lloc en els diferents discs resolució, els quals fan ús del seu buffer per interpolar les mesures i fan ús del seu disc per consolidar-les. 

El conjunt de discs resolució constitueixen la part principal d'una base de dades multiresolució tot i que hi pot haver variacions en aquest esquema, com per exemple un buffer d'entrada de mesures comú que regularitzi la sèrie temporal des d'un principi i simplifiqui els interpoladors que són complicats quan es fa el pas de sèrie temporal no regular a regular.


En el capítol \todo{? més endavant}
 utilitzant el llenguatge de programació Python es dissenya, a nivell acadèmic, un sistema de gestió de bases de dades que implementa el model de dades tal com s'ha definit en aquest capítol.


En resum, a partir del model de dades multiresolució descrit en aquest capítol per una banda es poden estudiar quin efecte té una configuració determinada de paràmetres i per altra banda es poden dissenyar sistemes de gestió de bases de dades assegurant que implementen el model i per tant que tenen el funcionament desitjat.






%%% Local Variables:
%%% TeX-master: "main"
%%% End:
% LocalWords:  SGSTM
